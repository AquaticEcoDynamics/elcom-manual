[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "ELCOM Manual",
    "section": "",
    "text": "Welcome\nThis is a draft of the ELCOM manual. It is being written using Quarto and will be published as a Quarto book.\nThe ELCOM manual is a work in progress. It is being written by the ELCOM development team and is intended to be a comprehensive guide to using ELCOM for hydrodynamic and thermodynamic modeling of stratified water bodies. The manual will cover the following topics:\n\nIntroduction to ELCOM\nSetting up an ELCOM simulation\nRunning an ELCOM simulation\nPost-processing ELCOM simulation results",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "01-intro.html",
    "href": "01-intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "1.1 The ELCOM model\nELCOM (Estuary and Lake Computer Model) is a numerical modeling tool that applies hydrodynamic and thermodynamic models to simulate the temporal behavior of stratified water bodies with environmental forcing.\nThe hydrodynamic simulation method solves the unsteady, viscous Navier-Stokes equations for incompressible flow using the hydrostatic assumption for pressure. Modeled and simulated processes include baroclinic and barotropic responses, rotational effects, tidal forcing, wind stresses, surface thermal forcing, inflows, outflows, and transport of salt, heat and passive scalars.\nThrough coupling with the CAEDYM (Computational Aquatic Ecosystem DYnamics Model) water quality module, ELCOM can be used to simulate three-dimensional transport and interactions of flow physics, biology and chemistry.\nThe hydrodynamic algorithms in ELCOM are based on the Euler-Lagrange method for advection of momentum with a conjugate-gradient solution for the free-surface height (Casulli and Cheng, 1992). Passive and active scalars (i.e., tracers, salinity and temperature) are advected using a conservative ULTIMATE QUICKEST discretization (Leonard 1991).",
    "crumbs": [
      "Overview",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "01-intro.html#implementation-language",
    "href": "01-intro.html#implementation-language",
    "title": "1  Introduction",
    "section": "1.2 Implementation language",
    "text": "1.2 Implementation language\nELCOM is implemented in Fortran 90 (with F95 extensions) so that three-dimensional space can be mapped into a single vector for fast operation using array-processing techniques.\nOnly the computational cells that contain water are represented in the single vector so that memory usage is minimized. This allows Fortran 90 compiler parallelization and vectorization without platform-specific modification of the code. A future extension of ELCOM will include dynamic pressure effects to account for nonlinear dynamics of internal waves that may be lost due to the hydrostatic approximation.",
    "crumbs": [
      "Overview",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "01-intro.html#outline-of-a-simulation-run",
    "href": "01-intro.html#outline-of-a-simulation-run",
    "title": "1  Introduction",
    "section": "1.3 Outline of a simulation run",
    "text": "1.3 Outline of a simulation run\nSetting up and running an ELCOM simulation requires the following steps:\n\nPrepare bathymetry.dat file that provides topography and grid information (see Section 6.2),\nPrepare bc.dat file that designates sets of cells for applying boundary conditions (see Section 6.3),\nPrepare levee.dat file that designates sets of cells for levee boundary conditions (see Section 6.11),\nPrepare update.dat file that designates sets of cells for update boundary conditions (see Section 6.12),\nRun the pre-processor to produce sparsedata.unf and usedata.unf files,\nConfigure the simulation run_elcom file (see Section 7.7),\nSpecify output in a datablock file (*.db) for designating data output operations (see Section 7.9.3),\nPrepare temporal boundary condition files (*.dat) for data applied to the boundary condition cells (see Section 7.8.2),\nPrepare initial conditions files (see Section 7.4),\nRun the executable, directing the screen output to a file (see Section 7.10),\nPost-process data (see Section 7.10.1).",
    "crumbs": [
      "Overview",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "01-intro.html#conventions-and-definitions",
    "href": "01-intro.html#conventions-and-definitions",
    "title": "1  Introduction",
    "section": "1.4 Conventions and definitions",
    "text": "1.4 Conventions and definitions\nIn this document, a number of conventions will be used. For clarity, the computational domain will generally be referred to as a “lake”. However, the simulation method is designed for applicability to estuaries and coastal ocean environments.\n\n\n\n\n\n\n\nTerm\nDefinition\n\n\n\n\nx,y,z space\nFull Cartesian space which covers all of the bathymetry\n\n\ni,j,k space\nDiscrete integer space of computational cells which covers all bathymetry\n\n\nland\nA computational cell that cannot contain water\n\n\nopen\nA cell used for an open boundary condition\n\n\ninterior\nA cell that may contain water\n\n\nx_rows\nNumber of grid cells in the x direction\n\n\ny_columns\nNumber of grid cells in the y direction\n\n\nz_layers\nNumber of grid cells in the vertical (z) direction\n\n\nland_value\nNumber used in the bathymetry file to represent land cells\n\n\nopen_value\nNumber used in the bathymetry file to represent open boundary cells\n\n\ndx, dy, dz\nGrid spacing in x, y, z directions (can be uniform or non-uniform, in meters)",
    "crumbs": [
      "Overview",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "sci-hydrodynamics.html",
    "href": "sci-hydrodynamics.html",
    "title": "2  Hydrodynamics",
    "section": "",
    "text": "2.1 Governing Equations\nContent to be added.\nThe hydrodynamic model in ELCOM solves the unsteady, Reynolds-averaged Navier-Stokes equations for incompressible flow using the hydrostatic assumption for pressure. This chapter describes the governing equations and their discretization.",
    "crumbs": [
      "Science Description",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Hydrodynamics</span>"
    ]
  },
  {
    "objectID": "sci-hydrodynamics.html#momentum-equations",
    "href": "sci-hydrodynamics.html#momentum-equations",
    "title": "2  Hydrodynamics",
    "section": "2.2 Momentum Equations",
    "text": "2.2 Momentum Equations\nContent to be added.",
    "crumbs": [
      "Science Description",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Hydrodynamics</span>"
    ]
  },
  {
    "objectID": "sci-hydrodynamics.html#free-surface-evolution",
    "href": "sci-hydrodynamics.html#free-surface-evolution",
    "title": "2  Hydrodynamics",
    "section": "2.3 Free-Surface Evolution",
    "text": "2.3 Free-Surface Evolution\nContent to be added.",
    "crumbs": [
      "Science Description",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Hydrodynamics</span>"
    ]
  },
  {
    "objectID": "sci-hydrodynamics.html#coriolis-and-barotropicbaroclinic-forcing",
    "href": "sci-hydrodynamics.html#coriolis-and-barotropicbaroclinic-forcing",
    "title": "2  Hydrodynamics",
    "section": "2.4 Coriolis and Barotropic/Baroclinic Forcing",
    "text": "2.4 Coriolis and Barotropic/Baroclinic Forcing\nContent to be added.",
    "crumbs": [
      "Science Description",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Hydrodynamics</span>"
    ]
  },
  {
    "objectID": "sci-hydrodynamics.html#boundary-conditions",
    "href": "sci-hydrodynamics.html#boundary-conditions",
    "title": "2  Hydrodynamics",
    "section": "2.5 Boundary Conditions",
    "text": "2.5 Boundary Conditions\nContent to be added.",
    "crumbs": [
      "Science Description",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Hydrodynamics</span>"
    ]
  },
  {
    "objectID": "sci-transport.html",
    "href": "sci-transport.html",
    "title": "3  Transport and Mixing",
    "section": "",
    "text": "3.1 Scalar Transport Equation\nContent to be added.\nELCOM transports passive and active scalars (tracers, salinity, temperature) using a conservative ULTIMATE QUICKEST discretization. This chapter describes the advection and diffusion schemes.",
    "crumbs": [
      "Science Description",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Transport and Mixing</span>"
    ]
  },
  {
    "objectID": "sci-transport.html#advection-scheme",
    "href": "sci-transport.html#advection-scheme",
    "title": "3  Transport and Mixing",
    "section": "3.2 Advection Scheme",
    "text": "3.2 Advection Scheme\nContent to be added.",
    "crumbs": [
      "Science Description",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Transport and Mixing</span>"
    ]
  },
  {
    "objectID": "sci-transport.html#horizontal-diffusion",
    "href": "sci-transport.html#horizontal-diffusion",
    "title": "3  Transport and Mixing",
    "section": "3.3 Horizontal Diffusion",
    "text": "3.3 Horizontal Diffusion\nContent to be added.",
    "crumbs": [
      "Science Description",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Transport and Mixing</span>"
    ]
  },
  {
    "objectID": "sci-transport.html#numerical-conservation-properties",
    "href": "sci-transport.html#numerical-conservation-properties",
    "title": "3  Transport and Mixing",
    "section": "3.4 Numerical Conservation Properties",
    "text": "3.4 Numerical Conservation Properties\nContent to be added.",
    "crumbs": [
      "Science Description",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Transport and Mixing</span>"
    ]
  },
  {
    "objectID": "sci-thermodynamics.html",
    "href": "sci-thermodynamics.html",
    "title": "4  Surface Thermodynamics",
    "section": "",
    "text": "4.1 Surface Heat Budget\nContent to be added.\nThe surface thermodynamics module computes the heat exchange across the air-water interface. This chapter describes the components of the surface heat budget and their parameterization.",
    "crumbs": [
      "Science Description",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Surface Thermodynamics</span>"
    ]
  },
  {
    "objectID": "sci-thermodynamics.html#shortwave-radiation",
    "href": "sci-thermodynamics.html#shortwave-radiation",
    "title": "4  Surface Thermodynamics",
    "section": "4.2 Shortwave Radiation",
    "text": "4.2 Shortwave Radiation\nContent to be added.",
    "crumbs": [
      "Science Description",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Surface Thermodynamics</span>"
    ]
  },
  {
    "objectID": "sci-thermodynamics.html#longwave-radiation",
    "href": "sci-thermodynamics.html#longwave-radiation",
    "title": "4  Surface Thermodynamics",
    "section": "4.3 Longwave Radiation",
    "text": "4.3 Longwave Radiation\nContent to be added.",
    "crumbs": [
      "Science Description",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Surface Thermodynamics</span>"
    ]
  },
  {
    "objectID": "sci-thermodynamics.html#latent-and-sensible-heat-fluxes",
    "href": "sci-thermodynamics.html#latent-and-sensible-heat-fluxes",
    "title": "4  Surface Thermodynamics",
    "section": "4.4 Latent and Sensible Heat Fluxes",
    "text": "4.4 Latent and Sensible Heat Fluxes\nContent to be added.",
    "crumbs": [
      "Science Description",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Surface Thermodynamics</span>"
    ]
  },
  {
    "objectID": "sci-thermodynamics.html#equation-of-state",
    "href": "sci-thermodynamics.html#equation-of-state",
    "title": "4  Surface Thermodynamics",
    "section": "4.5 Equation of State",
    "text": "4.5 Equation of State\nContent to be added.",
    "crumbs": [
      "Science Description",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Surface Thermodynamics</span>"
    ]
  },
  {
    "objectID": "sci-turbulence.html",
    "href": "sci-turbulence.html",
    "title": "5  Turbulence Closure",
    "section": "",
    "text": "5.1 Overview of Mixing Parameterizations\nContent to be added.\nELCOM provides several turbulence closure options for vertical mixing of momentum and scalars. This chapter describes the available closure schemes and their applicability.",
    "crumbs": [
      "Science Description",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Turbulence Closure</span>"
    ]
  },
  {
    "objectID": "sci-turbulence.html#wind-mixed-layer-model",
    "href": "sci-turbulence.html#wind-mixed-layer-model",
    "title": "5  Turbulence Closure",
    "section": "5.2 Wind-Mixed Layer Model",
    "text": "5.2 Wind-Mixed Layer Model\nContent to be added.\nThe recommended closure for wind-driven stratified flows (iclosure = 6) computes turbulent kinetic energy from wind stirring, convective overturns, and shear production.",
    "crumbs": [
      "Science Description",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Turbulence Closure</span>"
    ]
  },
  {
    "objectID": "sci-turbulence.html#unstable-mixing",
    "href": "sci-turbulence.html#unstable-mixing",
    "title": "5  Turbulence Closure",
    "section": "5.3 Unstable Mixing",
    "text": "5.3 Unstable Mixing\nContent to be added.",
    "crumbs": [
      "Science Description",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Turbulence Closure</span>"
    ]
  },
  {
    "objectID": "sci-turbulence.html#bottom-boundary-layer",
    "href": "sci-turbulence.html#bottom-boundary-layer",
    "title": "5  Turbulence Closure",
    "section": "5.4 Bottom Boundary Layer",
    "text": "5.4 Bottom Boundary Layer\nContent to be added.",
    "crumbs": [
      "Science Description",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Turbulence Closure</span>"
    ]
  },
  {
    "objectID": "sci-turbulence.html#background-potential-energy-conservation",
    "href": "sci-turbulence.html#background-potential-energy-conservation",
    "title": "5  Turbulence Closure",
    "section": "5.5 Background Potential Energy Conservation",
    "text": "5.5 Background Potential Energy Conservation\nContent to be added.",
    "crumbs": [
      "Science Description",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Turbulence Closure</span>"
    ]
  },
  {
    "objectID": "02-pre.html",
    "href": "02-pre.html",
    "title": "6  Pre-Processor",
    "section": "",
    "text": "6.1 Introduction\nThe ELCOM pre-processor is used to convert the user’s three-dimensional data of lake bathymetry, boundary forcing sections, and grid structure into one-dimensional vectors used by ELCOM. Configuration for running the pre-processor comes from a run_pre.dat file. The run_pre.dat file is a text file that contains the names and locations of user-supplied input files and pre-processor output files. The pre-processor requires two or three user-supplied text files: bathymetry.dat, bc.dat and optionally levee.dat and update.dat.\nThe pre-processor outputs two Fortran unformatted (binary) files: sparsedata.unf and usedata.unf. These may be renamed, but the user must track which are sparsedata and which are usedata.",
    "crumbs": [
      "Using ELCOM",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Pre-Processor</span>"
    ]
  },
  {
    "objectID": "02-pre.html#introduction",
    "href": "02-pre.html#introduction",
    "title": "6  Pre-Processor",
    "section": "",
    "text": "bathymetry.dat describes the bathymetry of the lake and grid configuration.\nbc.dat defines sets of boundary cells.\nlevee.dat allows the specification of levee cells — solid walls between two adjacent ELCOM cells.\nupdate.dat allows the specification of update cells — to modify values of various scalars arbitrarily.",
    "crumbs": [
      "Using ELCOM",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Pre-Processor</span>"
    ]
  },
  {
    "objectID": "02-pre.html#sec-bathFile",
    "href": "02-pre.html#sec-bathFile",
    "title": "6  Pre-Processor",
    "section": "6.2 Setting up the bathymetry file (bathymetry.dat)",
    "text": "6.2 Setting up the bathymetry file (bathymetry.dat)\nELCOM uses Fortran 90 (with F95 extensions) to map 3D space into a single vector for fast operation. Only computational cells containing water are represented in the vector, minimizing memory usage. This enables parallelization/vectorization without platform-specific modifications. Future ELCOM versions may include dynamic pressure effects to handle nonlinear internal wave dynamics.\n\n6.2.1 Introduction\nThe bathymetry file allows the user to input the simulation domain geometry at the target resolution1.\nThe format is strict with respect to data amount and order. All items must be present. Comment lines can be added before bathymetry values, with each line containing at least two items. An item may be an integer, real number, or character string. Comments must begin with an exclamation point (!) and include at least two items. A common crash involves a Fortran error due to missing non-optional items or insufficient items per line.\nBelow are valid formats:\nkeyword data data keyword ! comment keyword keyword data(j=1 to y_columns)\nThe keywords are ELCOM-defined words that indicate the type of user-provided data presented: (1) before the keyword, (2) after the keyword, or (3) on succeeding lines of the file.\nAdditional comments may be provided after the keywords to help the user remember the keyword purpose (the code only reads the first two items on a line). Detailed information on the keywords and the format of the file are presented in the following sections.\n\n\n6.2.2 Physical and computational space coordinates\nIn the literature, bathymetry is generally presented as the vertical distance from some horizontal baseline (often a mean water height) and may be either positive downward or positive upward. The convention used in ELCOM is an \\(({x,y,z})\\) space that follows the right-hand rule and has \\(z\\) positive in the upward direction (Figure 6.1).\nThe user is free to choose any suitable \\(z=0\\) baseline for the bathymetry as long as positive \\(z\\) upward is maintained as the convention for measurement. The pre-processor will adjust the user-defined \\(z=0\\) baseline to an internal code baseline that is suitable for the ELCOM simulation.\nFor the most part, the user does not need to know or consider this internal baseline adjustment. However, some debugging or monitoring output is presented in terms of the code coordinate system rather than the user coordinate system, so care must be taken in interpreting debugging output that is intended for use by code developers.\nThe position of the physical space origin \\((x=0, y=0)\\) is set implicitly by the user through the layout of the bathymetry data in the file bathymetry.dat. This will be covered in more detail below. Physical space \\(x\\) and \\(y\\) values may not be negative (i.e., the \\(x,y\\) origin must be in a corner of the domain).\n\n\n\n\n\n\n\n\nFigure 6.1: Schematic of coordinate system\n\n\n\n\n\nELCOM performs its simulation on computational cells of a three-dimensional Cartesian mesh. The user needs to understand the layout of the mesh so that boundary condition cells can be properly identified. ELCOM allows non-uniform spacing in each of the horizontal dimensions (\\(x\\) and \\(y\\)) and allows non-uniform spacing in the vertical (\\(z\\)) direction. (Although non-uniform \\(x\\) and \\(y\\) grid spacings are now allowed, users must be aware that timestep limitations are set by the smallest grid size.)\nFigure 6.2 shows a plan view (\\(x\\)-\\(y\\) plane) of a lake with a discrete (uniform) Cartesian mesh overlay. The computational domain is divided into “cells” whose centers are represented in Figure 6.2 by solid dots. Dashed lines represent the faces between the cells. Each cell center has an \\((i,j,k)\\) coordinate that designates its location in discrete computational space. The \\(i,j,k\\) values are the integer indices of a three-dimensional array.\nThe right-hand rule is used, with \\((i,j,k)\\) being non-zero, positive integer values; \\(k = 1\\) is associated with the lowermost cell layer in the domain. The \\((i,j)\\) pairs of a horizontal plane represent a matrix, so that by conventional mathematical notation the \\((1,1)\\) position is always in the upper left corner. The \\(i\\) index is the row index and increases down the page. The \\(j\\) index is the column index and increases across the page. The \\((i,j)\\) indices for corner cells are shown in Figure 6.2.\nFor convenience and consistency, the origin \\((0,0)\\) of the \\(x,y\\) (physical space) coordinates is taken to be at the \\((1,1)\\) location in the computational space \\(i,j\\) indices.\n\n\n\n\n\n\n\n\nFigure 6.2: Plan view of Cartesian mesh\n\n\n\n\n\nUsing the upper left corner as the origin may initially be confusing to users familiar with mirror-image storage (used by many graphics programs) where the lower left corner is stored in position \\(i=1,j=1\\). The problem with mirror-image storage is that a simple printout of bathymetry data always appears as an upside-down mirror image of the real world when viewed with a text processor or spreadsheet.\nThe present convention gives the user a What You See Is What You Get view of the bathymetry simply by opening the file with a word processor or importing into a spreadsheet. This convention has been found to be intuitive for users who are not graphics experts. However, caution needs to be taken when converting raw bathymetry data from graphics programs that use a mirror-image standard. Likewise, the direction of the positive \\(u\\) (\\(x\\) direction) velocity is confusing, as it is positive down the page.\nFigure 6.3 shows the physical space outline of the lake as the border of the shaded area. The discrete outline of a lake is shown with a heavy solid line. In developing a bathymetry.dat file for an ELCOM simulation, the user is required to provide bathymetry values (i.e., vertical distance measured from the user’s \\(z=0\\) baseline) for each of the cells within the discrete boundary of the lake. The region outside the lake boundary is defined as the “land” region.\nIn Figure 6.3, the cell center dots have been replaced with numbers that represent the distance from the user’s \\(z=0\\) baseline to the bottom of the lake. In this case, all of the “land” regions have been given a value of 99. Note that the boundary of the bathymetry data set shown in Figure 6.3 has land values around the entire boundary.\nIn general, it is required that either a land cell or open boundary cell surrounds the bathymetry data. For the purposes of the bathymetry.dat file, the user must provide bathymetry values for all cells in a rectangular array, including those cells that only contain land. ELCOM will only reserve computational memory for:\n\nThe cells which may contain water, and\nThe first layer of land cells surrounding the water cells.\n\n\n\n\n\n\n\n\n\nFigure 6.3: Plan view of bathymetry data\n\n\n\n\n\nFigure 6.4 shows an elevation view (in the \\(x\\text{-}z\\) plane) of a lake with a Cartesian overlay. A continuous, physical-space lake bottom is shown as a dashed line, with the resulting discrete lake bottom shown as a solid line.\nELCOM computes the bathymetry on the face of each cell (the dashed lines) from user-supplied bathymetry data at the cell centers (on the solid dots). In this figure, the user \\(z=0\\) baseline is chosen as the top of the domain, so that all the bathymetry values should be negative. Note that the \\(k=1\\) index of \\(i,j,k\\) space corresponds with the lowermost layer, regardless of the user z=0 baseline position.\n\n\n\n\n\n\n\n\nFigure 6.4: Elevation view of bathymetry data\n\n\n\n\n\nAn up-to-date copy of bathymetry.dat is included in the examples. This file can be used as a template for creating your own bathymetry.dat file. The judicious use of extra comment lines and comments after the keywords leads to a file that is much more readable. The bathymetry.dat file can be renamed, but the corresponding name in the run_pre.dat must also be changed.\nThe remainder of this section will detail the use of each keyword in the bathymetry.dat file.\n\n\n6.2.3 File header\nkeyword = FILE\nThe first non-comment line of the bathymetry.dat file must begin with the keyword FILE. Thus, the first non-comment line must appear as shown:\n \n\n\n\nKeyword\nValue\n\n\n\n\nFILE\nbathymetry.dat\n\n\n\n\n6.2.3.1 Description lines\nkeywords = TITLE, ANALYST, ORGANIZATION, COMMENT\nSeveral keywords are provided to allow the user to put identifying information at the top of the bathymetry file. This information is printed to the standard output at the start of the run to provide identification of the debugging output data. The format for the header lines is 'string'; keyword, where the string must be a non-null character array enclosed in single quotation marks. If the string is left blank or not enclosed in quotes, the pre-processor will crash with a Fortran read error. The user must have only one COMMENT line. A typical set of header keywords is shown below.\n \n\n\n\nValue\nKeyword\n\n\n\n\n'Lake Nowhere'\nTITLE\n\n\n'J. Citizen'\nANALYST\n\n\n'A Company'\nORGANIZATION\n\n\n'test run number 1'\nCOMMENT\n\n\n\n\n\n\n6.2.4 Size of input bathymetry data\nkeywords = x_rows, y_columns, z_layers, n_max, n_maxBC\nIn order to correctly read the bathymetry data from file bathymetry.dat, the user must tell the pre-processor the size of grid to expect. The value for x_rows is the number of rows in a two dimensional plan view of the bathymetry. The y_columns is the number of columns in the two-dimensional plan view. The number of layers in the vertical direction is identified with the keyword z_layers. The keyword n_max is used to set an estimate of the number of grid cells in the domain that are required for simulation (i.e. interior points plus the land points in one layer surrounding the interior). For most simulations, n_max can be set to 0, and the code will start with an estimate of x_rows × y_columns × z_layers. However, in some cases, this may create a temporary data array larger than can be processed using the available memory and the pre-processor will crash. The crash may produce a machine error message stating “out of memory,” or a more enigmatic “segmentation fault”. If insufficient memory is available, the user can estimate the actual number of grid points required for the simulation and rerun the preprocessor. Further reduction of the amount of memory used can be achieved by using the keyword n_maxBC. n_maxBC sets the maximum number of cells in any one boundary condition set. If n_maxBC is not specified or is set to 0 then the calculated n_max value is used.\n\n\n\nValue\nKeyword\n\n\n\n\n102\nx_rows\n\n\n84\ny_columns\n\n\n22\nz_layers\n\n\n0\nn_max\n\n\n\n\n\n\n6.2.5 Land cells\nkeyword = land_value\nThe land region is designated by a unique bathymetry value (defined using the keyword land_value) that is greater than any value found within the lake. The user is free to choose the land_value as any convenient number that meets this criterion. Thus, if the user chooses a z=0 baseline at the very top of the domain, the land_value may be set to zero (and all the bathymetry values should be negative numbers). If the user chooses the bottom of the domain as the z=0 baseline, then the land_value may be any positive number that is greater than the largest number appearing within the lake boundary (it is usually convenient to use 9999). In this latter case, all the bathymetry values will be positive numbers. Note that any cell whose bathymetry is not equal to the land_value is considered a cell within the domain; thus typographical errors can produce spurious interior cells of the domain. The user is not required to have a z=0 baseline within the domain: it may be convenient to use an external reference such as sea level. This may result in the lowest point in the domain having a positive non-zero bathymetry value.\n\n\n\nValue\nKeyword\n\n\n\n\n9999\nland_value\n\n\n\n\n\n\n6.2.6 Open boundary cells\nkeyword = open_value\nOpen boundary cells are boundaries with tidal forcing from an adjacent body of water that is not in the simulation domain. The user-defined bathymetry value that indicates an open boundary cell is defined with the keyword open_value.\n\n\n\nValue\nKeyword\n\n\n\n\n8888\nopen_value\n\n\n\n\n\n\n6.2.7 North vector\nkeywords = north_x, north_y\nThe user may create a bathymetry data file with any orientation (i.e., there is no requirement that north be at the top of the page). Since wind forcing on the free surface requires a direction, the user must designate the north direction. The north vector is determined as shown in Figure 6.5. Note that the north vector is given in terms of a vector in physical (\\(x,y,z\\)) space, not the discrete (\\(i,j,k\\)) space. Because the origin is in the upper left corner, a standard “north up” data set has a north vector of (-1, 0).\n\n\n\nValue\nKeyword\n\n\n\n\n-1.0\nnorth_x\n\n\n0.5\nnorth_y\n\n\n\n\n\n\n\n\n\nFigure 6.5: Calculation of the north vector\n\n\n\n\n\n\n6.2.8 Geographic position\nkeywords = latitude, longitude, altitude\nThe user provides the geographic position of the simulation domain using the keywords latitude, longitude and altitude. Longitude and altitude have no effect on the simulation but longitude is used to geo-reference output data. The latitude is used to provide appropriate Coriolis forcing in the ELCOM simulation. North latitudes are entered as positive numbers while south latitudes are entered as negative numbers. Latitude and longitude refer to the top,left corner of the bathymetry file.\n\n\n\nValue\nKeyword\n\n\n\n\n-32.0\nlatitude\n\n\n9.46\nlongitude\n\n\n0.0\naltitude\n\n\n\n\n\n\n6.2.9 Horizontal grid spacing\nkeywords = x_grid, y_grid\nThe present version of ELCOM allows uniform or stretched grid spacing in the \\(x\\) and \\(y\\) direction. Separate grid spacings are implemented in each horizontal dimension so that \\(dx \\neq dy\\) is valid. However, the user should be careful in implementing a solution grid with different \\(dx\\) and \\(dy\\) grid spacings since this can affect the solution accuracy. For uniform grids the \\(x\\) and \\(y\\) grid spacings are designated with the keywords x_grid and y_grid. If a non-uniform (stretched) horizontal grid is used, a default value for x_grid and y_grid must still be defined.\n\n\n\nValue\nKeyword\n\n\n\n\n100.0\nx_grid\n\n\n100.0\ny_grid\n\n\n\n\n\n6.2.10 Non uniform horizontal grid spacing\nkeywords = dx, dy (optional)\nIn the horizontal direction, ELCOM version 2.0.0 allows the user to design a grid whose dimension varies in space (i.e. \\(dx = f[x]\\) and \\(dy = f[y]\\)). Note that the \\(dx\\) may not vary with \\(y\\) or \\(z\\) coordinates and \\(dy\\) may not vary with \\(x\\) or \\(z\\) coordinates. In the bathymetry.dat file, stretched horizontal grid spacings are designated by the keywords dx and dy. dx and dy are defined in the bathymetry.dat in the order of increasing coordinate (i.e. from \\(x=1\\) to \\(x = x\\_rows\\)).\nWhile the user is free to set the \\(dx\\) and \\(dy\\) values in an arbitrary manner, the accuracy and stability of the simulation method may be affected by the degree of non-uniformity of the grid. In general, the simulation method will perform best (i.e. with greatest accuracy) using a uniform grid. For non-uniform grids, the degradation of accuracy is a function of the rate at which the grid changes (see below for \\(dz\\)).\n\n\n\nValue\nKeyword\n\n\n\n\n100\ndx\n\n\n100\ndx\n\n\n120\ndx\n\n\n132\ndx\n\n\n145\ndx\n\n\n150\ndx\n\n\n165\ndx\n\n\n171\ndx\n\n\n188\ndx\n\n\n205\ndx\n\n\n205\ndx\n\n\n205\ndx\n\n\n205\ndx\n\n\n205\ndx\n\n\n\n\n\n\nValue\nKeyword\n\n\n\n\n100\ndy\n\n\n100\ndy\n\n\n120\ndy\n\n\n132\ndy\n\n\n145\ndy\n\n\n150\ndy\n\n\n165\ndy\n\n\n171\ndy\n\n\n188\ndy\n\n\n205\ndy\n\n\n205\ndy\n\n\n205\ndy\n\n\n205\ndy\n\n\n205\ndy\n\n\n\n\n\n\n6.2.11 Layer thickness\nkeyword = dz\nIn the vertical direction, ELCOM allows the user to design a structure of horizontal layers whose thickness varies with depth (i.e. \\(dz = f[z]\\)). Note that the layer thickness may not vary with \\(x\\) or \\(y\\) coordinates. In the bathymetry.dat file, the successive layer thicknesses (in descending order from the top of the domain) are designated by the keyword dz. While the user is free to set the \\(dz\\) values in an arbitrary manner, the accuracy and stability of the simulation method may be affected by the degree of non-uniformity of the layers. In general, the simulation method will perform best (i.e. with greatest accuracy) using a grid with uniform \\(dz\\). For non-uniform \\(dz\\), the degradation of accuracy is a function of the rate at which the \\(dz\\) changes. Thus, a grid that has a \\(dz\\) that varies slowly will perform very well, while a grid with abrupt changes in grid size will be less accurate. For example, Figure 6.6 shows two possible configurations which provide vertical resolution of 0.5 metres in the upper portion of a lake and 2.0 metre resolution in the lower portion. Both use the same number of grid cells, but the \\(dz\\) distribution on the left of Figure 6.6 will show better performance.\n\n\n\nValue\nKeyword\n\n\n\n\n0.5\ndz\n\n\n0.5\ndz\n\n\n0.5\ndz\n\n\n0.51\ndz\n\n\n0.54\ndz\n\n\n0.58\ndz\n\n\n0.65\ndz\n\n\n0.75\ndz\n\n\n0.90\ndz\n\n\n1.13\ndz\n\n\n1.41\ndz\n\n\n1.65\ndz\n\n\n1.88\ndz\n\n\n2.0\ndz\n\n\n\n\n\n\n\n\n\n\nFigure 6.6: Vertical grid spacings\n\n\n\n\n\n6.2.12 Bathymetry values\nkeywords = BATHYMETRY DATA\nThe bathymetry values must be presented in the file bathymetry.dat following a line with the two keywords BATHYMETRY DATA. Each line of bathymetry values must contain exactly y_columns of data and there must be exactly x_rows of data lines following BATHYMETRY DATA. Each value on the line may be separated from the next by one or more spaces or tabs.\nThus, for a domain with x_rows = 8 and y_columns = 13, and land_value = 99 (i.e., similar to Figure 6.2), the bathymetry values would be entered into the bathymetry.dat file as shown:\nBATHYMETRY DATA\n99  99  99   99   99   99   99   99   99   99   99   99   99\n99  99  -0.7 -0.5 99   99   99   99   99   99   99   99   99\n99  -0.4 -1.2 -1.3 -1.1 -1.4 -2.5 -2.7 -3.3 -0.7 99   99   99\n99  -1.1 -1.6 -2.2 -3.2 -3.8 -3.9 -4.1 -5.3 -5.7 -5.2 -2.4 99\n99  -0.5 -0.8 -1.2 -2.1 -2.2 -2.4 -3.2 -3.3 -4.1 -5.0 -1.8 99\n99  99  99   99   99   99   99   99   99   -1.7 -1.2 -0.7 99\n99  99  99   99   99   99   99   99   99   -0.7 -0.9 -0.3 99\n99  99  99   99   99   99   99   99   99   99   99   99   99\n\n\n6.2.13 Bottom drag values (optional)\nKeywords: BTM_CD DATA\nVersion 2.0.0 allows a variable bottom drag coefficient to be specified in the bathymetry.dat file. Each line of values must contain exactly y_columns of data and there must be exactly x_rows of data lines following BTM_CD DATA. Each value on the line may be separated from the next by one or more spaces.\nThus, for the domain with x_rows = 8 and y_columns = 13, the values would be entered into the bathymetry.dat file as shown:\nBTM_CD DATA\n8 13 1e+16\n1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16\n1e+16 1e+16 0.002 0.002 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16\n1e+16 0.002 0.002 0.002 0.002 0.002 0.002 0.002 0.002 0.002 1e+16 1e+16 1e+16\n1e+16 0.003 0.003 0.003 0.003 0.003 0.003 0.003 0.003 0.003 0.003 0.003 1e+16\n1e+16 0.004 0.004 0.004 0.004 0.004 0.004 0.004 0.004 0.004 0.004 0.004 1e+16\n1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 0.004 0.004 0.004 1e+16\n1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 0.004 0.004 0.004 1e+16\n1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16\n\n\n6.2.14 Bottom Slope Values (Optional)\nKeywords: SLOPE_X DATA, SLOPE_Y DATA\nTo enable the 2D underflow model, bottom slope values must be included in the bathymetry.dat file. These values should follow a line containing either of the keywords SLOPE_X DATA or SLOPE_Y DATA.\nEach line of slope values must contain exactly y_columns entries, and there must be exactly x_rows lines of data following the keyword. Values on a line can be separated by one or more spaces or tabs.\nFor instance, if the domain is defined with x_rows = 8 and y_columns = 13 (as shown earlier), the slope values would appear in the bathymetry.dat file as follows:\n\nExample SLOPE_X DATA Format\nSLOPE_X DATA\n8 13 1e+16\n\n1e+16  1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16\n1e+16  1e+16 -0.006 -0.008 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16\n1e+16 -0.007 -0.004 -0.008 -0.021 -0.024 -0.019 -0.020 -0.026 -0.05 1e+16 1e+16 1e+16\n1e+16 -0.000 0.002 0.000 -0.005 -0.004 0.000 -0.002 0.000 -0.017 -0.025 -0.009 1e+16\n1e+16  0.005 0.008 0.011 0.016 0.019 0.0195 0.020 0.026 0.02 0.02 0.008 1e+16\n1e+16  1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 0.017 0.020 0.007 1e+16\n1e+16  1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 0.008 0.006 0.003 1e+16\n1e+16  1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16\n\n\nExample SLOPE_Y DATA Format\nSLOPE_Y DATA\n8 13 1e+16\n\n1e+16  1e+16  1e+16   1e+16   1e+16   1e+16   1e+16   1e+16   1e+16   1e+16   1e+16   1e+16   1e+16\n1e+16  1e+16 -0.002   0.003   1e+16   1e+16   1e+16   1e+16   1e+16   1e+16   1e+16   1e+16   1e+16\n1e+16 -0.008 -0.004   0.000  -0.000  -0.007  -0.006  -0.004   0.01    0.016   1e+16   1e+16   1e+16\n1e+16 -0.008 -0.005  -0.008  -0.008  -0.003  -0.001  -0.007  -0.008   0.000   0.016   0.026   1e+16\n1e+16  1e+16  1e+16   1e+16   1e+16   1e+16   1e+16   1e+16   1e+16   0.017   0.005   0.006   1e+16\n1e+16  1e+16  1e+16   1e+16   1e+16   1e+16   1e+16   1e+16   1e+16  -0.004   0.002   0.004   1e+16\n1e+16  1e+16  1e+16   1e+16   1e+16   1e+16   1e+16   1e+16   1e+16   1e+16   1e+16   1e+16   1e+16",
    "crumbs": [
      "Using ELCOM",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Pre-Processor</span>"
    ]
  },
  {
    "objectID": "02-pre.html#sec-bcFile",
    "href": "02-pre.html#sec-bcFile",
    "title": "6  Pre-Processor",
    "section": "6.3 Setting up the boundary cell set file (bc.dat)",
    "text": "6.3 Setting up the boundary cell set file (bc.dat)\nAn up-to-date copy of bc.dat is included in the examples.",
    "crumbs": [
      "Using ELCOM",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Pre-Processor</span>"
    ]
  },
  {
    "objectID": "02-pre.html#introduction-2",
    "href": "02-pre.html#introduction-2",
    "title": "6  Pre-Processor",
    "section": "6.4 Introduction",
    "text": "6.4 Introduction\nThe boundary cell set file designates logical grouping of grid cells over which boundary conditions are enforced in ELCOM. One set of points may have a river inflow, another set may have a dam offtake, another set may represent groundwater inflows, etc. Each set of boundary points is defined by a unique reference number (used also by ELCOM temporal boundary condition files), type (one of several keywords), title (user reference only), and a series of cell i, j, k coordinates. This file gives the user complete flexibility in the assignment of diverse and complex boundary conditions around a three-dimensional topography.",
    "crumbs": [
      "Using ELCOM",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Pre-Processor</span>"
    ]
  },
  {
    "objectID": "02-pre.html#boundary-cell-set-categories",
    "href": "02-pre.html#boundary-cell-set-categories",
    "title": "6  Pre-Processor",
    "section": "6.5 Boundary cell set categories",
    "text": "6.5 Boundary cell set categories\nThe keywords for the boundary cell sets fall into seven categories, defined as follows:\n\n\n\n\n\n\n\nKeyword\nDescription\n\n\n\n\nland\nCell boundary which is considered to be land, on which a Dirichlet no-slip condition is imposed on all components of the velocity, and a Neumann zero-gradient condition is imposed on transported scalars.\n\n\nslip\nCell boundary which is considered to be land, but on which the velocity components tangential to the boundary have a Neumann free-slip condition applied, while the normal component of the velocity is a Dirichlet no-flux condition (this may be thought of more precisely as normal Dirichlet, tangential Neumann, or NDTN). A Neumann zero-gradient condition is imposed on transported scalars.\n\n\nflow\nCell boundary through which an inflow or outflow will be imposed as a Dirichlet fixed velocity condition. This also enforces a Dirichlet condition on transported scalars.\n\n\nsection\nCell boundary which is grouped into a set for application of an environmental forcing or scalar forcing boundary condition, but does not change the underlying form of the velocity boundary condition (e.g., the free surface may be divided into sections over which different wind conditions may be enforced - the type velocity boundary condition is not changed, but its magnitude is adjusted on different sections).\n\n\nopen\nCell boundary which is open to inflows and outflows from another body of water where the velocity is not fixed a priori (i.e., not a Dirichlet boundary) but is a function of the baroclinic and barotropic forcing near the boundary.\n\n\nbubbler\nAn interior cell on which a bubble plume destratification will be simulated.\n\n\nflow_*_dynamic\nCell boundary through which flow is determined dynamically according to the head difference between two locations in the domain (implemented for horizontal culverts). The flow will be imposed as a Dirichlet fixed velocity condition and also enforces a Dirichlet condition on transported scalars.\n\n\n\nA boundary cell set consists of a collection of cell faces that are the boundaries between interior cell and land cells. The land boundary condition is the default for all faces of cells identified by the land_value in the bathymetry.dat file and for all boundary cell faces below the bathymetry data. As such, the user will rarely need to use a land boundary condition in the bc.dat file. For a lake without any inflows, outflows or special boundary conditions, the bc.dat file need not be present.",
    "crumbs": [
      "Using ELCOM",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Pre-Processor</span>"
    ]
  },
  {
    "objectID": "02-pre.html#boundary-cell-set-face-direction",
    "href": "02-pre.html#boundary-cell-set-face-direction",
    "title": "6  Pre-Processor",
    "section": "6.6 Boundary cell set face direction",
    "text": "6.6 Boundary cell set face direction\nThe cell faces of the boundaries are identified by the (i, j, k) coordinates of the interior cell and the direction from the cell center to the boundary. The conventions used are as follows:\n\n\n\n\n\n\n\nFace code\nDescription\n\n\n\n\nxp\nthe y-z cell face in the positive x direction from the cell center\n\n\nyp\nthe x-z cell face in the positive y direction from the cell center\n\n\nxm\nthe y-z cell face in the negative x direction from the cell center\n\n\nym\nthe x-z cell face in the negative y direction from the cell center\n\n\ntop\nthe x-y cell face above the cell\n\n\nall_sides\nall possible side boundary faces (i.e., all y-z and x-z faces)\n\n\nall\nall possible side boundary faces plus the bottom boundary",
    "crumbs": [
      "Using ELCOM",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Pre-Processor</span>"
    ]
  },
  {
    "objectID": "02-pre.html#boundary-cell-set-keywords",
    "href": "02-pre.html#boundary-cell-set-keywords",
    "title": "6  Pre-Processor",
    "section": "6.7 Boundary cell set keywords",
    "text": "6.7 Boundary cell set keywords\nThe keywords used to identify boundary cell sets are a concatenation of the categories and the face direction. The valid keywords are listed below:\n\n\n\n\n\n\n\n\n\nland_xp\nflow_xp\nslip_xp\nsection_xp\n\n\n\n\nland_xm\nflow_xm\nslip_xm\nsection_xm\n\n\nland_yp\nflow_yp\nslip_yp\nsection_yp\n\n\nland_ym\nflow_ym\nslip_ym\nsection_ym\n\n\nland_bottom\nflow_bottom\nslip_bottom\nsection_bottom\n\n\nland_all_sides\nflow_all_sides\nslip_all_sides\nsection_all_sides\n\n\nland_all\nflow_all\nslip_all\nsection_all\n\n\n\n\n\nsection_top\n\n\n\n\n\n\n\n\n\n\n\n\n\nbubbler\nbubbler_zbot\nbubbler_kbot\n\n\n\n\n\nopen_cell\n\n\n\n\n\nflow_multi_sides\n\n\n\n\n\nflow_xp_dynamic\nflow_xm_dynamic\nflow_yp_dynamic\nflow_ym_dynamic\n\n\n\nNOTE: bubbler_zbot and bubbler_kbot allow the user to specify the height of a bubble plume diffuser as either some height in metres (zbot) or number of cells from the bottom.",
    "crumbs": [
      "Using ELCOM",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Pre-Processor</span>"
    ]
  },
  {
    "objectID": "02-pre.html#sec-bcdat",
    "href": "02-pre.html#sec-bcdat",
    "title": "6  Pre-Processor",
    "section": "6.8 Organization of the boundary cell set file (bc.dat)",
    "text": "6.8 Organization of the boundary cell set file (bc.dat)\nAt the top of the boundary cell set file (bc.dat), the user may put any number of comment lines. Each comment line must start with an exclamation point (!) and have at least 3 items on the line (i.e., two words or numbers separated from the exclamation point and each other by spaces or tabs). After the initial comments, the boundary cell set file consists of a series of definitions of boundary sets. Each set consists of a set identification line followed by one or more lines of cell definitions. Each line must have three items on it or the pre-processor will crash with a Fortran file read error. Blank lines are not allowed in the boundary cell set file.\nEach set identification line is of the form: integer  keyword  title\nThe first item, integer, is a reference number for the boundary cell set that is used in preparing temporal boundary condition data files for the ELCOM simulation run (see Section 7.8.2). Each boundary cell set must have a unique integer reference number. The keyword is one of the valid keywords listed in the boundary cell set keywords table above. The title is a user-designated name for the boundary condition set. The title may have more than one word, although only the first word will be used by the code.\nAfter the set identification line, there will be one or more lines of cell definitions. A cell definition consists of three sets of numbers in the general form: i_{start}:i_{end}  j_{start}:j_{end}  k_{start}:k_{end}. For all boundary condition types except bubbler_zbot and bubbler_kbot the i, j, and k are integer values of the cell positions in space for a rectangular box of cells on which the relevant boundary cell keyword will be applied. For bubbler_zbot the third column must be a single real which gives the height of the diffuser in metres above the lake bottom. For bubbler_kbot the third column must be a single integer which gives the number of cells the diffuser is above the lake bottom. An example of a simple boundary cell set definition might be\n  107  flow_xp  river_inflow\n   3:10  4:5  10:14\nThe preprocessor would designate as a single set, all positive x boundaries in the range \\(3 \\leq i \\leq 10\\) and \\(4 \\leq j \\leq 5\\) and \\(10 \\leq k \\leq 14\\). A boundary cell set may have multiple lines of cell definitions:\n  13  flow_bottom  groundwater_inflow\n    5:10   1:5    10:14\n    5:10   7:11   10:14\n    3:8   12:17   1:5\nNote that each number pair in a cell definition must be in increasing order.\nThere are two simpler cases for implementing boundary cell sets (1) where \\(i, j\\) or \\(k\\) is a single value rather than a range, (2) where all possible values in \\(i, j\\) or \\(k\\) are to be included. In the former case, only a single number needs to be provided (rather than a pair), in the latter case, only the colon (:) needs to be listed. For example, the cell set for an inflow boundary along a flat side where \\(j = 2\\) might be written as:\n  214  slip_all  freeslip_domain\n    :  :  :\nwhich enforces a free-slip boundary condition on all boundary faces (sides and bottom) of the domain.\nThere is no error cross-checking within the pre-processor for cell faces which have been defined as belonging to more than one boundary cell set. In some cases, multiple definitions may be desirable. For example, one might define a river inflow which covers the entire depth of the river for purposes of the velocity boundary condition; and then define a separate section at the bottom of the river that is used to place a tracer. The bc.dat file might then contain\n  2791  flow_ym     river_inflow\n    3:15    2    :\n  73    section_ym  tracer_inflow\n    3:15    2    1:5\nIn other cases, multiple set definitions for a particular face can produce unintended results. For example, if we define an inflow boundary and a global definition of free-slip boundaries on all the cells:\n2791    flow_ym river_inflow\n    3:15    2   :\n214 slip_all    freeslip_domain\n    :   :   :\nWe then find that the cells (3:15, 2, : ) get defined both with imposed velocity (Dirichlet) boundary conditions and free-slip (normal-Dirichlet, tangential-Neumann) boundary conditions. Obviously this is inconsistent and the flow simulation cannot enforce both boundary conditions. Checking for which combinations of multiple definitions are consistent and which are not is an error capturing routine that is not yet implemented. Thus, the above boundary cell sets would be processed and provided to ELCOM. Within ELCOM, only one of the two boundary conditions will actually be enforced, but one cannot tell a priori which boundary condition it will be without detailed examination of source code. Note that the order the items are defined may affect the operation of an inconsistent definition. Thus if the above inconsistent definition were reversed and written as:\n214 slip_all    freeslip_domain\n    :   :   :\n2791    flow_ym river_inflow\n    3:15    2   :\nThe results in ELCOM may be different than the previous implementation — they would be wrong in a different manner. As a general rule, the user should not provide multiple definitions of velocity boundary conditions on a single cell face. The land, flow and slip keywords all affect the type of velocity boundary condition; it is incumbent on the user to be sure that the cell faces defined with these types do not have multiple definitions.\nThe following table illustrates a bc.dat file with a few subtle uses of the boundary cell set definitions. A flow boundary has been declared on the x-minus faces of cells with \\(i=2\\). Thus, to get free-slip boundary conditions on all the other faces, we use the keyword slip_all for cells with \\(i&gt;2\\). Then to get free slip on the y-minus and y-plus faces at \\(i=2\\) requires two more definitions (These are not inconsistent with the flow_xm definition since they are on different faces of the same cell). This file also shows the use of the section_top to segregate the free surface into different sets onto which different wind data can be enforced.\n! - - - -\n! - bc.dat file\n! - comment lines need three items\n34  flow_xm   outflow_number_1\n    2       :       :\n75  section_top  wind_region_a\n    :       1:10    :\n118 section_top  wind_region_b\n    :       11:21   :\n25  slip_all_sides  free_slip_section\n    3:34    :       :\n26  slip_ym free_slip_near_inflow_1\n    2:      :       :\n27  slip_yp free_slip_near_inflow_2\n    2:      :       :",
    "crumbs": [
      "Using ELCOM",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Pre-Processor</span>"
    ]
  },
  {
    "objectID": "02-pre.html#flow_multi_sides",
    "href": "02-pre.html#flow_multi_sides",
    "title": "6  Pre-Processor",
    "section": "6.9 flow_multi_sides",
    "text": "6.9 flow_multi_sides\nIn ELCOM version 2.1.1 a further bc set type was introduced (flow_multi_sides) which allows the user to specify one inflow which enters from multiple cells on multiple faces. This was primarily introduced to allow a meandering river channel to be specified as one boundary set and will be particularly useful when coupled with INFLOW_DEPTH boundary condition data. The format of flow_multi_sides in the boundary cell set file (bc.dat) is slightly different from other set types.\nEach flow_multi_sides set consists of a set identification line followed by one or more subsets of cell and face type definitions. Each line must have three items on it or the pre-processor will crash with a Fortran file read error. Blank lines are not allowed in the boundary cell set file.\nEach flow_multi_sides set identification line is the same as for all other set types, i.e.:\nreference number keyword title\nWhere keyword must be flow_multi_sides. After the set identification line, there will be one or more subset definitions. Each subset consists of a subset set identification line followed by one or more lines of cell definitions.\nEach subset identification line is of the form: reference number flow_multi_sides keyword. The subset reference number for each subset must be the same as the reference number from the set identification line. The keyword. must be one of flow_xp, flow_xm, flow_yp, or flow_y and defines the inflow face or the subset of cells.\nFollowing each subset identification line are one or more lines of cell definitions. These cell definitions are the same as for an ordinary set type—i.e., of the general form $i_{start}:i_{end} j_{start}:j_{end} k_{start}:k_{end}$.\nAn example of a flow_multi_sides boundary cell set definition might be:\n  111 flow_multi_sides    river_inflow\n  111 flow_multi_sides    flow_xm\n      2   3   10\n      3   3   9\n      4   3   8\n  111 flow_multi_sides    flow_ym\n      4   3   8\n      4   4   7\n      4   5   6\n  111 flow_multi_sides    flow_xm\n      4   5   6\n      5   5   5\n      6   5   4",
    "crumbs": [
      "Using ELCOM",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Pre-Processor</span>"
    ]
  },
  {
    "objectID": "02-pre.html#flow_dynamic",
    "href": "02-pre.html#flow_dynamic",
    "title": "6  Pre-Processor",
    "section": "6.10 flow_dynamic",
    "text": "6.10 flow_dynamic\nDynamic boundary condition sets (flow*_dynamic) allow the user to specify the connection of two parts of the domain with a (horizontal) culvert. This functionality was recently introduced in ELCOM. A boundary condition set pair related to each of the ends of the culvert must be defined.\nThe definition of a dynamic boundary condition pair set comprises four lines. The first and third lines have the same structure as the boundary condition identification line: a set reference number, one of the keywords (flow_xm_dynamic, flow_xp_dynamic, flow_ym_dynamic, or flow_yp_dynamic), and a user identifier. Each of these lines refers to one end of the culvert.\nThe second and fourth lines follow the same structure as the cell definition lines of an ordinary set type. Each line refers to one end of the culvert. Only one i and one j value can be specified. Although multiple k values may be included, both ends must have the same k specification.\nAn example of a flow*_dynamic boundary cell set definition might be:\n500     flow_xp_dynamic pipe_east_end\n        2   3   10\n600     flow_ym_dynamic pipe_north_end\n        4   3   10",
    "crumbs": [
      "Using ELCOM",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Pre-Processor</span>"
    ]
  },
  {
    "objectID": "02-pre.html#sec-leveeFile",
    "href": "02-pre.html#sec-leveeFile",
    "title": "6  Pre-Processor",
    "section": "6.11 Setting up the levee file (levee.dat) (Optional)",
    "text": "6.11 Setting up the levee file (levee.dat) (Optional)\n\n6.11.1 Introduction\nThe levee set file designates any levees in the domain. Levees are solid boundaries between two adjacent cells. Pre-ELCOM implements levees by adding additional ghost cells adjacent to the levee. These ghost cells are colocated with the wet cells.\nThe format of the levee set file is essentially the same as the bc.dat file. Each set of levee points is defined by a unique reference number, type (one of several keywords), title (user reference only), and a series of cell (i, j, k) coordinates.\n\n\n6.11.2 Levee set categories\nThe cell faces of the levees are identified by the (i, j, k) coordinates of the interior cell and the direction from the cell center to the levee. The four valid keywords for the levee sets are as follows:\n\n\n\n\n\n\n\nKeyword\nDescription\n\n\n\n\nlevee_xp\nLevee on the y-z cell face in the positive x direction from the cell center\n\n\nlevee_yp\nLevee on the x-z cell face in the positive y direction from the cell center\n\n\nlevee_xm\nLevee on the y-z cell face in the negative x direction from the cell center\n\n\nlevee_ym\nLevee on the x-z cell face in the negative y direction from the cell center\n\n\n\n\n\n6.11.3 Organization of the levee set file (levee.dat)\nAt the top of the levee.dat file, the user may include any number of comment lines. Each comment line must begin with an exclamation point ! and contain at least three items (i.e., two words or numbers separated from the ! and from each other by spaces).\nAfter the initial comments, the file contains a series of levee set definitions. Each set consists of a set identification line followed by one or more cell definition lines. Each line must have three items; otherwise, the pre-processor will fail with a Fortran file read error. Blank lines are not allowed.\nEach set identification line is of the form: integer keyword title.\n\ninteger: a reference number unique to each levee set\nkeyword: one of the valid keywords listed above\ntitle: a user-designated name for the levee set (only the first word is used by the code)\n\nEach cell definition consists of three fields in the form: i_start:i_end j_start:j_end : Here, i and j are integer values specifying a rectangular box of cells. The third field must be a colon (:), indicating that the levee acts on all z values.\nAn example of a simple levee set definition might be:\n107  levee_xp  levee_bank\n     3  4:15  :",
    "crumbs": [
      "Using ELCOM",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Pre-Processor</span>"
    ]
  },
  {
    "objectID": "02-pre.html#sec-updateFile",
    "href": "02-pre.html#sec-updateFile",
    "title": "6  Pre-Processor",
    "section": "6.12 Setting up the update file (update.dat) (Optional)",
    "text": "6.12 Setting up the update file (update.dat) (Optional)\n\n6.12.1 Introduction\nThe update set file defines update cells in the domain. These cells allow scalar values to be modified arbitrarily at run-time using Update boundary condition files (see Section 7.8.4). The format of this file is essentially the same as the bc.dat file.\nEach set is defined by a unique reference number, type (keyword), title (user reference), and a series of (i, j, k) cell coordinates.\n\n\n6.12.2 Update set categories\nUpdate cells are identified by their (i, j, k) coordinates. The valid keywords for update sets are:\n\n\n\n\n\n\n\nKeyword\nDescription\n\n\n\n\nupdate\nScalar values are set to those in the Update boundary condition files\n\n\nupdate_add\nScalar values are increased by the values in the Update boundary files\n\n\nupdate_max\nScalar values are set to the maximum of current and file value\n\n\nupdate_scale\nScalar values are multiplied by the file value\n\n\n\n\n\n6.12.3 Organization of the update set file (update.dat)\nComment lines may appear at the top of the file. Each comment must begin with ! and include at least three items. No blank lines are allowed in the file.\nEach update set includes a set identification line followed by one or more cell definition lines. Each line must have exactly three items to avoid pre-processor errors.\nEach set identification line is of the form: integer keyword title.\n\ninteger: a unique reference number\nkeyword: one of the valid update keywords\ntitle: a user-designated name (only the first word is used by the code)\n\nEach cell definition is of the form: i_start:i_end j_start:j_end k_start:k_end Here, i, j, and k define a rectangular box of update cells.\nAn example of a simple update set definition might be:\n12  update  tracer_release\n  3  4:15  2:4",
    "crumbs": [
      "Using ELCOM",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Pre-Processor</span>"
    ]
  },
  {
    "objectID": "02-pre.html#running-the-pre-processor-with-run_pre.dat",
    "href": "02-pre.html#running-the-pre-processor-with-run_pre.dat",
    "title": "6  Pre-Processor",
    "section": "6.13 Running the pre-processor with run_pre.dat",
    "text": "6.13 Running the pre-processor with run_pre.dat\nAn up-to-date copy of run_pre.dat is included in the examples.\nThe run_pre.dat file is a text file that contains the names and paths of the user-supplied input files and the pre-processor output files. The required input files are:\n\nbathymetry.dat: describes lake bathymetry and grid configuration\nbc.dat: defines boundary cell sets\n\nOptionally, it may also include:\n\nupdate.dat\nlevee.dat\n\nThe pre-processor outputs two unformatted Fortran binary files:\n\nsparsedata.unf\nusedata.unf\n\nThese files may be renamed by the user, but they must be tracked carefully to distinguish between sparsedata and usedata.\nOnce the run_pre.dat file is in place with correct file paths and names, the pre-processor is executed with:\npre_elcom.exe",
    "crumbs": [
      "Using ELCOM",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Pre-Processor</span>"
    ]
  },
  {
    "objectID": "02-pre.html#footnotes",
    "href": "02-pre.html#footnotes",
    "title": "6  Pre-Processor",
    "section": "",
    "text": "The pre-processor cannot interpolate between coarse/fine grids — this must be done manually beforehand.↩︎",
    "crumbs": [
      "Using ELCOM",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Pre-Processor</span>"
    ]
  },
  {
    "objectID": "03-elcom.html",
    "href": "03-elcom.html",
    "title": "7  ELCOM Operation",
    "section": "",
    "text": "7.1 Introduction\nRunning an ELCOM simulation requires the user to provide several types of data:\nELCOM obtains this data from the user through user-prepared input files and pre-processor prepared input files.",
    "crumbs": [
      "Using ELCOM",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>ELCOM Operation</span>"
    ]
  },
  {
    "objectID": "03-elcom.html#introduction",
    "href": "03-elcom.html#introduction",
    "title": "7  ELCOM Operation",
    "section": "",
    "text": "Initial conditions\nTemporal boundary conditions\nConfiguration parameters\nOutput control",
    "crumbs": [
      "Using ELCOM",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>ELCOM Operation</span>"
    ]
  },
  {
    "objectID": "03-elcom.html#files-for-elcom",
    "href": "03-elcom.html#files-for-elcom",
    "title": "7  ELCOM Operation",
    "section": "7.2 Files for ELCOM",
    "text": "7.2 Files for ELCOM\nELCOM is a command-line executable that communicates with the user through files. Table 7.1 provides a summary of file types, whether their presence is required or optional, the purpose of the file, and responsibility for preparation of the file.\n\nFile names in courier bold font without brackets are fixed named files (i.e., the file must be present with exactly that name).\nFile names such as [data_name].unf use square brackets to indicate that ELCOM may substitute various names in the bracketed section (see following sections).\nFile names such as .db use angle brackets to indicate sections of file names that the user can customize at the command line.\n\n\n\n\n\nTable 7.1: Files for ELCOM.\n\n\n\n\n\n\n\n\n\n\n\n\n\nFile.Name\nPresence\nUsage\nPreparation\nNumber\n\n\n\n\nrun_elcom.dat\nrequired\nconfiguration control\nuser\n1\n\n\n.db\noptional\noutput control\nuser\n1\n\n\n.dat\noptional\nboundary control\nuser\n10\n\n\n.dat\noptional\ninitial condition\nuser\n10\n\n\n.dat\noptional\nscalar updates\nuser\n10\n\n\n.dat\noptional\ndrifter properties\nuser\n10\n\n\n.dat\noptional\ndrifter initial conditions\nuser\n10\n\n\n.dat\noptional\ndrifter updates\nuser\n10\n\n\n.dat\noptional\njet/pump file\nuser\n100\n\n\n.dat\noptional\ndrafttube file\nuser\n100\n\n\n.dat\noptional\ntemporal filter constants\nuser\n10\n\n\n.unf\nrequired\ngeometry data\npre-processor\n1\n\n\n.unf\nrequired\ngeometry data\npre-processor\n1\n\n\n.unf\noutput\ndatablock output\nELCOM\nno limit\n\n\n[data_name].unf\noutput\n3D data type output\nELCOM\nno limit\n\n\n[time_].unf\noutput\nsimulation space output\nELCOM\nno limit\n\n\n.unf\noutput\nrestart file\nELCOM\n1\n\n\nelcom.exe\nrequired\nexecutable\nmake\n1",
    "crumbs": [
      "Using ELCOM",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>ELCOM Operation</span>"
    ]
  },
  {
    "objectID": "03-elcom.html#simulation-modules",
    "href": "03-elcom.html#simulation-modules",
    "title": "7  ELCOM Operation",
    "section": "7.3 Simulation modules",
    "text": "7.3 Simulation modules\nELCOM is organized into simulation modules that can be turned off/on depending on the type of simulation that is desired. A module is turned off/on by setting the value of control keywords. This is done within the run_elcom.dat file. These controls provide a simple method for modifying the simulation.\nFor example: a boundary condition file can be set up to include both meteorological data and inflow data. As a simple test, the user decides to turn off the inflow. One approach would be to return to the pre-processor, eliminate the inflow boundary cell set, re-run the pre-processor, then modify the temporal boundary condition file to remove the inflow data. As a simpler approach, the user need only set iflow = 0, and the inflow data and boundary cell sets will be ignored.\nThis section provides a brief overview of the modules within ELCOM and their corresponding keywords set within the run_elcom.dat file.\n\n7.3.1 Stratification\nDensity stratification in ELCOM can be through temperature, salinity, or both by using the controls itemperature and isalinity in combination with idensity = 1. If desired, temperature and salinity can be treated as passive tracers by setting idensity = 0. If temperature and/or salinity are turned on, they must be initialized throughout the simulation domain using the default_*** controls, initial condition files, or associated subroutines in elcom_user.f90.\n\n\n7.3.2 Tracers\nUp to 10 passive tracers may be transported in a simulation. They may be initialized in the domain using initial condition files or may flow into the domain through an inflow boundary using keywords TRACER_** in a temporal boundary condition file.\n\n\n7.3.3 Surface thermodynamics\nThis module controls the heat transfer across the free surface. Required inputs (in temporal boundary condition files) include: solar radiation, wind speed, air temperature, and relative humidity.\n\n\n7.3.4 Rain\nThe rain module controls rain input into the free surface. Rain data in m/day must be provided in a temporal boundary condition file.\n\n\n7.3.5 Wind\nWind affects ELCOM simulations in three ways:\n\nEvaporative cooling in the surface thermodynamics module\nWind stress on the free surface\nWind-induced momentum source in the wind-mixed layer\n\nUse WIND_SPEED and WIND_DIR (linked to boundary cell set 0 for uniform application) or define multiple sections via section_top in bc.dat. ELCOM interpolates wind speed and direction in time. Vector interpolation isn’t supported, so consistent time intervals are recommended. Alternatively, use WIND_U and WIND_V.\n\n\n7.3.6 Inflow/Outflow\nInflow/outflow boundaries must be defined in bc.dat. Temporal boundary conditions for flow rate must be provided. Inflow conditions must also include scalar values.\n\n\n7.3.7 Conservation of Background Potential Energy\nNumerical diffusion can destratify the domain, increasing background potential energy. A vertical sharpening filter can conserve energy but not mass. The filter applies to salinity (IFILTER = 2) or temperature (IFILTER = 3). Alternatively, use FILTER_&lt;SCALAR&gt; in run_elcom.dat with IFILTER = 1. Temporally varying filters are also supported.\n\n\n7.3.8 Bubble Plume Destratification\nTo simulate bubble destratification, define outlet locations in bc.dat. Temporal boundary conditions must specify airflow rates and the number of ports.\n\n\n7.3.9 Underflow\nTo simulate dense inflow using Dallimore et al. (2001)’s 2D model, define inflow boundaries and temporal conditions, including INFLOW_HEIGHT. Set IUNDERFLOW in run_elcom.dat. Note: Not compatible with CAEDYM.\n\n\n7.3.10 Water Age Modelling\nEnable using IRETENTION in run_elcom.dat. Water age starts at zero and increments by del_t each timestep. Transported as a scalar.\n\n\n7.3.11 Drifters / Particles\nSimulate Lagrangian or semi-Lagrangian particles using NDRIFTERS in run_elcom.dat. Define properties in drifter_properties_file and drifter_in_file. Updates via update_drifter_file.\n\n\n7.3.12 Jets/Pumps\nTo simulate jet/pump destratification, provide thrust, radius, and depth data in jet files. Controlled via IJET in run_elcom.dat.\n\n\n7.3.13 Drafttubes\nFor destratification impellors with draft tubes, specify thrust, radius, depth, and tube length in drafttube files. Controlled via ITUBE in run_elcom.dat.\n\n\n7.3.14 Non-hydrostatic code\nTo simulate non-hydrostatic pressure effects (as in Bothel et al.), note that finer horizontal resolution (~10m) is required and simulation runtime increases significantly.",
    "crumbs": [
      "Using ELCOM",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>ELCOM Operation</span>"
    ]
  },
  {
    "objectID": "03-elcom.html#sec-initfiles",
    "href": "03-elcom.html#sec-initfiles",
    "title": "7  ELCOM Operation",
    "section": "7.4 Initialization",
    "text": "7.4 Initialization\n\n7.4.1 Uniform initial conditions\nFor simple initial conditions (e.g., distributing a scalar or setting a flat surface), use DEFAULT_**** keywords in run_elcom.dat. Default values can be overwritten by profile or horizontal files or initialization subroutines.\n\n\n7.4.2 Vertical Profile\nVertical scalar variation is defined using initial_profile_file (in the infiles directory). Format:\n\nFour header lines:\n\nNumber of datasets (excluding depth)\nNumber of depths (first column is DEPTH)\ni and j coordinates\nColumn keywords (first must be DEPTH, rest valid scalar keywords)\n\nData rows: Depth (in meters) and scalar values.\nDepths must start at zero and increase monotonically.\nLinear interpolation is used during simulation.\n\n\nComments (!) can appear at the top of the file but not within the data block. Comment rows in headers must match column count.\n\n! Example: ic.dat\n2   data sets\n4   number of depths\n15 20   i,j\nDEPTH   WTR_TEMP    SALINITY\n0.0     25.0        0.0\n5.1     23.1        15.1\n6.2     20.2        35.0\n10.4    18.3        35.2\n\n\n7.4.3 Multiple Vertical Profiles\nTo increase the flexibility of initialization, ELCOM Version 2 allows for multiple profile initial condition files. If more than one initial condition file is specified for any scalar, then ELCOM interpolates between files to initialize the domain. Each profile is first linearly interpolated onto the vertical layers, and then each point is horizontally interpolated using the inverse distance weighting method such that\n\\[\nS_{i,j,k} = \\sum_{n=1}^N \\frac{S_{n,k}r_{n}^\\alpha}{r_{n}^\\alpha}\n\\]\nwhere \\(\\alpha\\) is the distance weighting specified by the flag IC_DIST_WEIGHTING in run_elcom.dat (default = 2.0), \\(r\\) is the distance between the column and profile \\(n\\), and \\(N\\) is the number of profiles.\n\n\n7.4.4 Horizontal Variation\nA horizontal variation in the initial conditions for any valid transportable scalar can be defined using an input file (keyword = initial_horiz_file). The input file may have any name but must be located in the infiles directory.\nThese files require a format that consists of three header lines followed by a value for each (i,j) column of the domain. The file may have as many comment lines (preceded by !) at the top of the file as desired. Comment lines within the header data must have as many items as there are columns (i.e., if there are 3 columns, a valid comment line is !  - -). No comment lines are allowed within the columns of data. The columns must be completely dense with data (i.e., there may not be “missing” data such that a row has fewer items than the number of columns).\nThe first header line contains two numbers: the number of x rows and the number of y columns. These must match the number of rows and columns in the bathymetry file.\nThe second line gives a land value for land cells.\nThe third line in the header contains the keyword that describes the scalar to be initialized. This keyword should be a valid transportable scalar given in the Valid Scalars table in Section 7.13.\nThe remaining lines in the file contain the data. The matrix should be the same size as the bathymetry data in your bathymetry file.\n! Example:  ic.dat\n8 13    xrows   yrows\n1e+16   land    val\nSALINITY\n1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16\n1e+16 1e+16   9.0   9.5 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16\n1e+16   8.1   8.5   9.3   9.5  10.0  10.2  11.0  11.6  11.8 1e+16 1e+16 1e+16\n1e+16   8.0   8.5   9.2   9.5  10.0  10.3  10.6  11.3  11.6  11.8  12.0 1e+16\n1e+16   8.0   8.5   9.1   9.3   9.5   9.5   9.7   9.8  10.0  10.2  11.2 1e+16\n1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16  10.0  10.0  10.5 1e+16\n1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16   9.1   9.2   9.5 1e+16\n1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16\n\n\n7.4.5 User subroutines\nFor ELCOM users who are willing to modify and compile source code, the ability to set up complex initial conditions is available through the addition of code to subroutines in the elcom_user.f90 file. The subroutines in this file are only called if the appropriate user_init_*** control in the run_elcom.dat file is non-zero.\nThe stub routines supplied with ELCOM are designed to be executed with the user_init_*** controls set to 1. However, this can be modified by the user so that different initializations are performed for different values of user_init_***.",
    "crumbs": [
      "Using ELCOM",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>ELCOM Operation</span>"
    ]
  },
  {
    "objectID": "03-elcom.html#configuration-controls",
    "href": "03-elcom.html#configuration-controls",
    "title": "7  ELCOM Operation",
    "section": "7.5 Configuration controls",
    "text": "7.5 Configuration controls\n\n7.5.1 Time step\nThe time step (keyword = del_t) is the number of seconds that the simulation advances in time for each simulation step.\n\n\n7.5.2 Number of steps\nThe total number of time steps to be computed in the present simulation run is set using the keyword iter_max in the run_elcom.dat file.\n\n\n7.5.3 Start date\nThe start date is entered in CWR Julian Day format, which specifies the year and day using a real number with 7 digits to the left of the decimal place as yyyyddd.ddd. The first 4 digits are the year and the subsequent 3 digits are the Julian Day (days since January 1st). Hours, minutes, and seconds are represented as fractions of a day (e.g., 1 AM on January 1st, 2000 is represented as 2000001.041667).\n\n\n7.5.4 CGM tolerance\nThe CGM_TOL is the residual at which iteration of the conjugate gradient method (used for the free-surface solution) is stopped.\n\n\n7.5.5 Turbulence\nFor stratified flow, the base closure scheme can be supplemented by unstable mixing (iclosure = 1) algorithms. The unstable mixing algorithm mixes momentum and transported scalars in vertical cells where an unstable gradient of potential density exists (i.e., Ri &lt; 0.0).\nFor stratified flows driven by surface wind, the wind-mixed-layer closure scheme with energy transport (iclosure = 6) is recommended. This approach computes the turbulent kinetic energy due to wind stirring, convective overturns, and wind shear, then uses this to compute vertical mixing.",
    "crumbs": [
      "Using ELCOM",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>ELCOM Operation</span>"
    ]
  },
  {
    "objectID": "03-elcom.html#output-frequency",
    "href": "03-elcom.html#output-frequency",
    "title": "7  ELCOM Operation",
    "section": "7.6 Output frequency",
    "text": "7.6 Output frequency\nOutputs of data that are not controlled by the datablock file are set through the iter_out_*** and start_output_*** keywords. The former controls the time step interval for providing output, while the latter controls the first step on which output will be provided.",
    "crumbs": [
      "Using ELCOM",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>ELCOM Operation</span>"
    ]
  },
  {
    "objectID": "03-elcom.html#sec-runelcom",
    "href": "03-elcom.html#sec-runelcom",
    "title": "7  ELCOM Operation",
    "section": "7.7 Configuration using file run_elcom.dat",
    "text": "7.7 Configuration using file run_elcom.dat\nAn up-to-date copy of run_elcom.dat is included in the examples.\nELCOM looks for the file run_elcom.dat in the local directory to set the configuration of the simulation run. The run_elcom.dat configuration file controls execution of optional modules and models within ELCOM, allowing the user to set the parameters that govern the physical and numerical simulation.\nThe format of the file is flexible: lines may occur in any order, and not all items must be present. Comment lines (preceded by !) may occur anywhere in the file. Blank lines are not allowed in the file (the code stops reading at a blank line). Each line (including comment lines) must have at least two items separated by a blank space.\nThe comment marker ! counts as an item, so a valid line is !  ! or ! -, while !! (no space between) is not valid.\nThe general format for the file is a series of lines, with each line listing a user setting followed by a keyword that defines the parameter. The individual keywords and settings are explained briefly below:\n\n7.7.1 File headers\n\nFILE: file name for this file (must be run_elcom.dat)\nANALYST: user name (must be inside single quotes ' ')\nORGANIZATION: user company name (must be inside single quotes ' ')\nCOMMENT: user comment (must be inside single quotes ' ')\nCASE_KEYWORD: allows user to add code to be executed for a particular simulation case. Must be a string without blank spaces enclosed in single quotes.\n\n\n\n7.7.2 Simulation module controls\n\niheat_input: controls surface thermodynamics\n\n0 = no surface thermodynamics\n1 = surface thermodynamics model (input solar radiation is measured; longwave model determined by input keywords)\n\niatmstability: controls atmospheric stability correction in thermodynamics\n\n0 = no correction\n1 = apply correction\n\nirain: controls rainfall input\n\n0 = no rain\n1 = rain enabled\n\niflow: controls inflow/outflow (Dirichlet boundaries); overrides boundary condition files\n\n0 = no inflow/outflow\n1 = inflow/outflow model 1\n\niunderflow: controls 2D underflow model; overrides boundary condition files\n\n0 = standard inflow modelling\n1 = use underflow model where INFLOW_HEIGHT is specified\n\nibubbler: controls bubble plume destratification\n\n0 = no bubble plume\n1 = enable destratification model\n\nitemperature: controls whether temperature is transported\n\n0 = no temperature\n1 = temperature as scalar\n\nisalinity: controls whether salinity is transported\n\n0 = no salinity\n1 = salinity as scalar\n\nidensity: controls inclusion of buoyancy (density) in simulation\n\n0 = no buoyancy\n1 = use UNESCO equation of state for buoyancy\n\nntracer: number of passive tracers\n\n0 = none\n1 to 10 = number of tracers initialized or supplied via inflow\n\nndrifters: number of drifters or particles\n\n0 = none\n\n=1 = number of drifters\n\n\nijet: include jets/pumps\n\n0 = no jets\n1 = simulate jets\n\nitube: include drafttube pump destratification\n\n0 = no drafttubes\n1 = simulate drafttubes\n\nICAEDYM: enable CAEDYM water quality module\n\n0 = off\n1 = on\n\nicoriolis: include Coriolis force from bathymetry.dat latitude\n\n0 = off\n1 = on\n\ninonhydrostatic: use non-hydrostatic approximations of Botelho et al.\n\n0 = hydrostatic\n1 = non-hydrostatic\n\n\n\n\n7.7.3 Initialization and update options\n\nirestart: use restart file for initial conditions\n\n0 = do not use\n1 = use file specified by restart_in_file\n\nuser_init_u_vel: user subroutine for x velocity\n\n0 = ignore\n1 = call user_u_init with USER_START_U = 1\n\nuser_init_v_vel: user subroutine for y velocity\n\n0 = ignore\n1 = call user_v_init with USER_START_V = 1\n\nuser_init_w_vel: user subroutine for z velocity\n\n0 = ignore\n1 = call user_w_init with USER_START_W = 1\n\nuser_init_temperature: user subroutine for temperature\n\n0 = ignore\n1 = call user_temperature_init with USER_START_TEMPERATURE = 1\n\nuser_init_salinity: user subroutine for salinity\n\n0 = ignore\n1 = call user_salinity_init with USER_START_SALINITY = 1\n\nuser_init_tracer: user subroutine for tracer\n\n0 = ignore\n1 = call user_tracer_init with USER_START_TRACER = 1\n\nuser_init_height: user subroutine for surface height\n\n0 = ignore\n1 = call user_height_init with USER_START_HEIGHT = 1\n\nuser_init_extinction: user subroutine for light extinction coefficient\n\n0 = ignore\n1 = call user_extinction_init with USER_START_EXTINCTION = 1\n\nlatitude: optional simulation latitude (overrides value in bathymetry.dat)\n\n\n\n7.7.4 Turbulence modeling\n\niclosure: controls the type of closure scheme used\n\n0 = constant eddy viscosity\n1 = closure model 1 (includes mixing of unstable stratification)\n6 = wind-mixed layer model with energy transport — RECOMMENDED\n\nDIFFUSIVITY&lt;SCALAR&gt;: horizontal diffusivity for a scalar in X and Y (same). &lt;SCALAR&gt; must be uppercase and valid.\nDIFFUSIVITY_X_&lt;SCALAR&gt;, DIFFUSIVITY_Y_&lt;SCALAR&gt;: horizontal diffusivities in X and Y directions separately.\nDEFAULT_DIFFUSIVITY: default horizontal diffusivity for scalars; overridden by scalar-specific settings.\n\n\n\n7.7.5 Meteorological Sensor Heights\n\nWIND_SPEED_HEIGHT: height (m) of wind speed measurements. Default is 10 m.\nSCALAR_HEIGHT: height (m) for air temperature and humidity data. Default is 10 m.\n\n\n\n7.7.6 Model Settings and Controls\n\nmean_albedo: mean albedo of water\ndrag_btm_cd: bottom drag coefficient\nmodel_grav_damp_x: damping for x-baroclinic term\nmodel_grav_damp_y: damping for y-baroclinic term\n\n\n\n7.7.7 Scalar Maximum and Minimum for Debugging\n\nmin_&lt;SCALAR&gt; and max_&lt;SCALAR&gt;: bounds for debugging. &lt;SCALAR&gt; must be uppercase.\nihardlimit:\n\n0 = no limits\n1 = apply scalar bounds\n\n\n\n\n7.7.8 Debugging controls\n\ndebug_check:\n\n0 = off\n1 = stop on fatal\n2 = high check, stop on fatal\n3 = high check, stop on warning\n\ndebug_print:\n\n0 = none\n1 = minimal\n2 = moderate\n10 = extensive\n\ndebug_point: sparse data index point for debug output\ndebug_baroclinic_x, debug_baroclinic_y:\n\n0 = off\n1 = on\n\n\n\n\n7.7.9 Output Frequency\n\niter_out_monitor: output interval for monitoring\niter_out_save: output interval for saved simulation\niter_out_restart: output interval for restart files\n\n\n\n7.7.10 Output Start Time\n\nstart_output_monitor: time step to start monitoring output\nstart_output_save: time step to start save files\nstart_output_restart: time step to start restart files\n\n\n\n7.7.11 Time Controls\n\nstart_date_CWR: start in Julian format yyyyddd.ddd\ndel_t: time step (seconds)\niter_max: max time steps\n\n\n\n7.7.12 Iterative Solver Controls\n\nCGM_TOL: tolerance for conjugate gradient method\nCGM_MIN: minimum iterations\nCGM_MAX: maximum iterations\n\n\n\n7.7.13 Scalar Filtering\n\nIFILTER:\n\n1 = off (default)\n2 = BPE filter for salinity\n3 = BPE filter for temperature\n\nfilter_bPE_threshold: max BPE change (e.g., 1e-9 for Lake Kinneret)\nfilter_mass_threshold: max mass change (e.g., 1e-7 for Lake Kinneret)\nFILTER&lt;SCALAR&gt;: constant filter value for scalar\nDEFAULT_FILTER: default filter value for all scalars\n\n\n\n7.7.14 Default Values\n\nDEFAULT_HEIGHT: default water height (m)\nDEFAULT_WIND_SPEED: default wind speed (m/s)\nDEFAULT_WIND_DIR: wind direction (degrees from North)\nDEFAULT_&lt;SCALAR&gt;: default scalar value\nDEFAULT_PAR_EXTINCTION, DEFAULT_NIR_EXTINCTION, DEFAULT_UVA_EXTINCTION, DEFAULT_UVB_EXTINCTION: extinction coefficients\nDEFAULT_BC: boundary condition preset (1-9)\n\n\n\n7.7.15 Input File Names\n\n3D_data_file, preprocessor_file: grid and map files\ninitial_profile_file, initial_horiz_file: initial condition files\nboundary_condition_file, profile_boundary_condition_file: boundary files\nupdate_file, filter_file: updates and filter files\ndrifter_properties_file, drifter_in_file, update_drifter_file: drifter config\njet_file, drafttube_file: destratification devices\ndatablock_file: output configuration\n\n\n\n7.7.16 File Directories\n\ninfile_dir: directory of input files\noutfile_unf_dir: binary output directory\noutfile_txt_dir: text output directory\n\n\n\n7.7.17 Output File Names\n\nrestart_save_file: base name for save files\nrestart_out_file: base name for restart output",
    "crumbs": [
      "Using ELCOM",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>ELCOM Operation</span>"
    ]
  },
  {
    "objectID": "03-elcom.html#input-files",
    "href": "03-elcom.html#input-files",
    "title": "7  ELCOM Operation",
    "section": "7.8 Input files",
    "text": "7.8 Input files\n\n7.8.1 sparsedata.unf and usedata.unf\nThe files sparsedata.unf and usedata.unf are required files for ELCOM. These are the Fortran unformatted (binary) files produced by the pre-processor. The user may rename these files, but must keep track of which file is the sparsedata file (3D_data_file) and which is the usedata file (preprocessor_file). ELCOM will look for the files specified in the run_elcom.dat file. If the incorrect files are used, the simulation will crash.\n\n\n7.8.2 Temporal boundary condition (1D) files\nThe one-dimensional temporal boundary condition files (boundary_condition_file) are created by the user to provide environmental forcing information that varies with time. These files must follow a specific format:\n\nFour header lines followed by data columns.\nFirst column = time in CWR format (yyyyddd.dd).\nEach row represents data for a specific time.\nComment lines (starting with !) may appear at the top.\nHeader comment lines must have the same number of items as data columns.\nNo comments allowed within the data block.\nAll columns must be fully populated (no missing values).\n\n\n7.8.2.1 Header line meanings:\n\nNumber of data columns (excluding the time column).\n0 indicating CWR time format (first data column should be TIME).\nBoundary cell set reference numbers (from bc.dat).\nKeywords describing the type of data in each column.\n\nInterpolation: ELCOM linearly interpolates between provided time values to match simulation time steps (del_t).\n\n\n7.8.2.2 Table: Temporal Boundary Condition Data-types\n\n\n\n\n\n\n\n\nKeyword\nUnits\nDescription\n\n\n\n\nHEIGHT\nm\nWater height for open boundary condition\n\n\nINFLOW\nm3/s\nInflow volume\n\n\nINFLOW_MAXDEPTH\nm\nMax depth for inflow\n\n\nINFLOW_MINDEPTH\nm\nMin depth for inflow\n\n\nINFLOW_HEIGHT\nm\nInflow height for underflow model\n\n\nOUTFLOW\nm3/s\nOutflow volume\n\n\nGATE_&lt;n&gt;_TOP\nm\nTop of an inflow/outflow gate\n\n\nGATE_&lt;n&gt;_BOTTOM\nm\nBottom of an inflow/outflow gate\n\n\nGATE_&lt;n&gt;_OPEN\n-\nStatus of gate (1=open, 0=closed)\n\n\nAIRFLOW\nm3/s\nAirflow rate for bubble destratification\n\n\nN_PORTS\n\nNumber of ports in destratification device\n\n\nRAIN\nm/day\nRainfall rate\n\n\nWIND_SPEED\nm/s\nWind speed\n\n\nWIND_DIR\ndeg\nWind direction (deg clockwise from north)\n\n\nSOLAR_RAD\nW/m2\nSolar radiation at water surface\n\n\nLW_RAD_IN\nW/m2\nIncoming longwave radiation\n\n\nLW_RAD_NET\nW/m2\nNet longwave radiation (positive incoming)\n\n\nATM_PRESS\nPascals\nAtmospheric pressure\n\n\nCLOUDS\n\nFractional cloud cover (0 to 1)\n\n\nREL_HUM\n\nRelative humidity (0 to 1)\n\n\nAIR_TEMP\ndeg C\nAir temperature\n\n\n&lt;SCALAR&gt;\n-\nValid transportable scalar\n\n\n\n\n\n7.8.2.3 Notes:\n\nINFLOW_MAXDEPTH and INFLOW_MINDEPTH: allow control of inflow depths, enabling inflow at the surface of a thalweg cell even as surface level varies.\nGATE_&lt;n&gt;_TOP, GATE_&lt;n&gt;_BOTTOM, GATE_&lt;n&gt;_OPEN: specify selective withdrawal gates. n is the gate number (e.g. GATE_1_TOP), with OPEN = 1 (open) or 0 (closed). Flow is distributed among open gates based on area.\n\nThese features allow for more realistic simulation of systems like reservoirs with variable surface height or dam withdrawal structures.\n\n\n\n7.8.3 Temporal profile boundary condition (2D) files\nThe two-dimensional temporal profile boundary condition files (profile_boundary_condition_file) are used to provide scalar boundary information that varies with both time and depth. These files consist of:\n\nFour header lines\nSections of data, each representing a profile at a specific time\n\n\n7.8.3.1 Header lines:\n\nNumber of data sets per section (including DEPTH, excluding the TIME row)\nMust contain 0 to indicate CWR time format; data section starts with TIME\nBoundary cell set reference numbers (including TIME and DEPTH) — each file may apply to only one boundary set\nKeywords for each column (TIME, DEPTH, and valid scalar keywords)\n\n\n\n7.8.3.2 Data section:\nEach section contains:\n\nOne header row: the profile time (yyyyddd.dd) and number of depths\nOne row for DEPTH values (depths in meters below the surface)\nSubsequent rows: one per scalar, with values at each depth\n\nAll sections must:\n\nContain the same number of data rows (one per scalar)\nMaintain the same order of keywords per section\n\n\n\n\n\n7.8.4 Update boundary condition files\nThe update boundary condition files (update_file) are used to update scalar values on boundaries during specified time intervals (e.g., tracer releases). Format is the same as 1D temporal boundary condition files, except:\n\nTwo TIME columns per row are provided\nScalar values are applied during timesteps between the first and second time column\n\nIf a timestep doesn’t fall within any of these intervals, no update is applied.\n\n\n\n7.8.5 Temporal filter constant files\nTemporal filter constant files (filter_file) provide time-varying filter constants for scalars. They follow the same format as the 1D temporal boundary condition files.\n\nThird header line still includes boundary cell set reference, but it is ignored\nAll keywords must be valid transportable scalars\n\n\n\n\n7.8.6 Drifter files\n\n7.8.6.1 Drifter Properties Files\nThe drifter properties file (drifter_properties_file) provides physical properties of semi-Lagrangian drifters. If only Lagrangian particles are simulated, this file can be blank.\nEach line contains four columns:\n\nValue\nTarget drifters (e.g., :, or n1:n2)\nTarget components (e.g., :, or n1:n2)\nProperty keyword\n\n\n\n7.8.6.2 Valid property keywords:\n\nmass: mass of the component (kg)\narea: cross-sectional area (m2)\nlength: vertical length (m)\ndrag_cd: drag coefficient\ndistance: vertical distance from probe base to component base (m)\n\n\n\n7.8.6.3 shape keyword values:\n\n1 = sphere\n2 = cylinder\n3 = rectangle\n\n\n\n7.8.6.4 type keyword values:\n\n1 = submerged — forced by modeled water velocities\n2 = subsurface — forced by surface wind shear velocity\n3 = surface — forced by wind\n\nTherefore an example file for drifters consisting of five components (antenna, surface buoy, subsurface buoy, pole connecting the drogue to the subsurface buoy and the drifter sails) may look something like:\n! - - - -\n! ! Example Drifter Properties File\n! ! NB each comment line should have 4 words\n! - - - -\n! Component 1 sail\n26.0   :    1    mass\n1.5    :    1    area\n1.0    :    1    length\n0.3    :    1    drag_cd\n0.0    :    1    distance\n3      :    1    shape\n1      :    1    type\n! Component 2 Pole\n3.0    :    2    mass\n0.001  :    2    area\n1.0    :    2    length\n0.3    :    2    drag_cd\n1.0    :    2    distance\n2      :    2    shape\n1      :    2    type\n! Component 3 sub-surface float\n0.2    :    3    mass\n0.2    :    3    area\n0.2    :    3    length\n0.3    :    3    drag_cd\n2.3    :    3    distance\n3      :    3    shape\n2      :    3    type\n! Component 4 surface float\n0.1    :    4    mass\n0.01   :    4    area\n0.1    :    4    length\n0.3    :    4    drag_cd\n2.5    :    4    distance\n3      :    4    shape\n3      :    4    type\n! Component 5 antennea\n1.0    :    5    mass\n0.01   :    5    area\n0.3    :    5    length\n0.3    :    5    drag_cd\n2.6    :    5    distance\n2      :    5    shape\n3      :    5    type\n\n\n\n7.8.7 Drifter Initial Files\nThe drifter initial files (drifter_in_file) are used to provide initial conditions and simulation properties for drifters and particles.\nEach line of the drifter_in_file should contain three columns: 1. A value 2. Target drifters (: for all, or n1:n2 for a range) 3. A keyword that specifies the property to set\n\n\n7.8.8 Valid keywords:\n\nstart_t: starting timestep for the drifter\nend_t: ending timestep for the drifter\nsolution_method: type of drifter\n\n1 = Drifter with constant elevation\n2 = Drifter with constant depth\n3 = Drifter with constant density\n4 = Lagrangian Particle with constant elevation\n5 = Lagrangian Particle with constant depth\n6 = Lagrangian Particle with constant density\n7 = 3D Lagrangian Particle\n\nbeach_method:\n\n1 = Remove drifter when it hits land\n2 = Drifter continues if it hits land &gt; Note: Drifters are always removed if they cross an open boundary.\n\ncfl_max: maximum timestep for drifter (sub-timestepped if CFL &gt; cfl_max)\ndrogue_density: density of drogue/particle (used for constant density solutions)\ncentre_of_mass: distance of centre of mass from bottom of drogue (used for constant density solutions)\ndepth: depth of bottom of drogue/particle (used for constant depth solutions)\nstart_i, start_j, start_k: starting position in i, j, k grid coordinates\n\nExample: start_i = 8.5, start_j = 8.5, start_k = 5.5 places the drifter in the center of cell (i = 8, j = 8, k = 5)\n\nstart_x, start_y, start_z: starting position in physical x, y, z coordinates\nstart_cell: starting cell number (in 1D sparse array)\n\n\nAn example file may look something like:\n! - - - -\n! ! Example Drifter Initial File\n! ! NB each comment line should have 3 words\n! - - - -\n8.5    :    start_i\n14.5   :    start_j\n6.7    :    start_k\n2      :    solution_method\n2      :    beach_method\n1.5    :    depth\n\n\n7.8.9 Drifter Update Files\nThe drifter update files (update_drifter_file) are used to update drifter positions or solution methods during a simulation. These files are primarily designed to incorporate real-time position updates from measurements.\nThe format is the same as standard update boundary condition files, except:\n\nThe third header line contains a drifter number instead of a boundary condition set number.\nThe update is applied to the specified drifter for all timesteps between the two time values on each row.\n\nIf the current timestep is not between the two specified time values of a row, no update is made.\n\n\n7.8.10 Valid keywords for updates:\n\nsolution_method: (see earlier for method options)\nbeach_method: (see earlier for options)\ncfl_max: maximum timestep (drifter is sub-timestepped if CFL &gt; cfl_max)\ndrogue_density: density of drogue/particle (for constant density mode)\ncentre_of_mass: vertical offset from bottom of drogue to its center of mass\ndepth: depth of drogue/particle (for constant depth solutions)\ni, j, k: updated grid coordinates for drifter position\nx, y, z: updated physical coordinates\ncell: updated cell index in 1D sparse array\n\n\nAn example file may look something like:\n! - - - -\n! ! Example Drifter Update File\n! ! NB each comment line  should have 3 words\n! - - - -\n2 data sets\n0 seconds between data\n0          0          1   1\nTIME       TIME       i   j\n2005001.50 2005001.60 6.7 7.2\n\n\n7.8.11 Jet Files\nThe jet files (jet_file) are used to define the properties of a jet or pump employed for artificial destratification.\nThese files must follow a specific format:\n\nThree header lines\nFour columns of data\nData corresponds to specific instants of time and applies to a particular jet\nComments (!) are allowed at the top of the file\nAll data rows must be fully populated — no missing values allowed\n\n\n7.8.11.1 Header line definitions:\n\nJet reference number (used for debugging purposes only)\ni and j location of the jet (two integers)\nColumn headers for the data that follows\n\n\nNote: The expected structure of the third header line and the data columns can include variables like time, thrust, radius, and depth or height depending on the configuration, although this was not specified completely in the original text.\n\n TIME THRUST RADIUS DEPTH\n TIME THRUST RADIUS HEIGHT\nThe four data columns are\n\n\n7.8.11.2 Data Column Descriptions (Jet Files)\n\nTIME: The date in CWR Julian Day format (yyyyddd.ddd)\nTHRUST: Force of the pump in Newtons\nRADIUS: Radius of the pump in metres\nDEPTH or HEIGHT: Either the depth of the pump from the surface level or the height from the bottom (in metres)\n\n! - - - -\n! Example Jet File\n! - - - -\n1 jet ID number\n6 12 i,j location of jet data\nTIME      THRUST RADIUS DEPTH\n2005001.0 3000   2.0    2.2\n2005011.0 3000   2.0    2.2\n\n\n\n7.8.12 Drafttube Files\nThe drafttube files (drafttube_file) are used to define the properties of a pump with a drafttube used for artificial destratification.\nThese files must follow this structure:\n\nThree header lines\nFive columns of data\nEach row provides values at specific time instances for a single device\nComment lines (starting with !) may appear at the top of the file\nAll data columns must be complete — no missing values in any row\n\n\n7.8.12.1 Header line definitions:\n\nA drafttube reference number (used for debugging only)\nTwo integers indicating the i and j location of the device\nA line containing the column headers for the data that follows\n\n\nNote: The exact headers for the data columns (e.g., TIME, THRUST, RADIUS, DEPTH, LENGTH) should follow this third line, depending on what is specified for each simulation setup.\n\n TIME FLOW RADIUS DEPTH LENGTH\nThe four data columns are\n\n\n7.8.12.2 Data Column Descriptions (Drafttube Files)\n\nTIME: The date in CWR Julian Day format (yyyyddd.ddd)\nFLOW: Flow rate through the pump in m3/s Note: This value should be negative (i.e., pumping downward through the tube).\nRADIUS: Radius of the pump and tube in metres\nDEPTH: Depth of the pump from the surface level (in metres)\nLENGTH: Length of the draft tube in metres\n\n! - - - -\n! Example drafttube File\n! - - - -\n1 drafttube ID number\n6 12 i,j location of jet data\nTIME      FLOW RADIUS DEPTH  LENGTH\n2005001.0 -5   2.0    2.2    5.0\n2005011.0 -5   2.0    2.2    5.0",
    "crumbs": [
      "Using ELCOM",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>ELCOM Operation</span>"
    ]
  },
  {
    "objectID": "03-elcom.html#definition-of-culvert-characteristics-dynamic-boundary-conditions",
    "href": "03-elcom.html#definition-of-culvert-characteristics-dynamic-boundary-conditions",
    "title": "7  ELCOM Operation",
    "section": "7.9 Definition of Culvert Characteristics – Dynamic Boundary Conditions",
    "text": "7.9 Definition of Culvert Characteristics – Dynamic Boundary Conditions\nWhen dynamic boundary conditions are defined in pre_elcom, the characteristics of the culvert connecting the pair of boundary conditions must be provided. These characteristics are supplied in a file specified in run_elcom.dat using the keyword dynamic_boundary_condition_file.\nThese files require:\n\nThree header lines\nOne line listing culvert characteristics to be defined\nOne or more data rows for each culvert\n\nHeader Format:\n\nTwo values – boundary condition reference numbers (as defined in pre_elcom)\nOne value – number of characteristics being specified (between 3 and 12)\nOne value – number of pipes in the set (only circular pipes supported)\nOne line – column headers for culvert characteristics\n\n\n7.9.1 Supported Culvert Keywords and Defaults\n\n\n\n\n\n\n\n\nKEYWORD\nDefault\nDescription\n\n\n\n\nPIPE_K\n0.098\nInlet control factor K – unsubmerged pipe\n\n\nPIPE_M\n2.000\nInlet control exponent M – unsubmerged pipe\n\n\nPIPE_C\n0.398\nInlet control factor C – submerged pipe\n\n\nPIPE_Y\n0.670\nInlet control term Y – submerged pipe\n\n\nEPS_ENTRY\n0.500\nHead loss at pipe inlet\n\n\nEPS_EXIT\n1.000\nHead loss at pipe outlet\n\n\nEPS_FLAP_IN\n0.000\nHead loss for flapped gate at first boundary\n\n\nEPS_FLAP_OUT\n0.000\nHead loss for flapped gate at second boundary\n\n\nPIPE_MAN\n0.015\nManning’s coefficient\n\n\nPIPE_PHI\nrequired\nPipe diameter\n\n\nPIPE_LEN\nrequired\nPipe length\n\n\nPIPE_HEIGHT\nrequired\nPipe bottom height (relative to domain reference level)\n\n\n\n\n\n7.9.2 Example File\n! Boundary Condition file for Culverts\n2 1 ! Pair of dynamic sets\n7   ! data sets\n10  ! number of pipes\nEPS_ENTRY  EPS_EXIT EPS_FLAP_IN  PIPE_PHI  PIPE_LEN  PIPE_MAN  PIPE_HEIGHT\n0.500      1.000      0.100      0.500     15.0       0.015       2.750\n\n\n7.9.3 Output definition file (Datablock.db)\nThe file datablock.db is a text file produced by the user, and contains the configuration data used to set up the users output. The name for this file is specified by the user.\nA datablock.db file is structured as a series of blocks of instructions. Each block requires an exact number of lines, with specific instructions on each line. Each line contains a single instruction followed by a comment. The comment must begin with a “!” character. In manually editing datablock.db files, it is important to keep in mind that while blocks of instructions may be added or removed, lines within a block can only be modified, but not removed. The following will discuss the structure of each block of instructions.\n\n7.9.3.1 Datablock Description\nThe first 4 lines of a datablock.db are the datablock description. In order, they are the block descriptor, the current datablock version number, the number of output groups, and the number of output sets. Output groups and sets are described below.\n\n\n7.9.3.2 Group Description\nFollowing the datablock description are the group description blocks. A group represents a group of data to be output. A data group is defined as an output filename, datatypes to be output (i.e. TEMPERATURE, SALINITY, etc…), the location within the simulation domain of the points at which data is to be output, and the time at which data is to be output. If several groups are desired, the group descriptions must follow each other without breaks between them.\nA group description block contains 11 lines, which are as follows:\n\n\n\n\n\n\n\nLine\nDescription\n\n\n\n\n1\nBEGIN GROUP_DESCRIPTION — begin block statement\n\n\n2\nGroup reference number — an integer labelling the group, this can have any value\n\n\n3\nUser label — a name containing no blank spaces labelling the group\n\n\n4\nOutput filename — should include .unf suffix\n\n\n5\nSet reference number — an integer corresponding to a description of a set of points at which the data are to be output (sets will be described after groups)\n\n\n6\nNumber of datatypes in group — an integer indicating the desired number of datatypes to be output (i.e. TEMPERATURE, SALINITY, etc…)\n\n\n7\nShould read .TRUE., do not modify\n\n\n8\nOutput interval — an integer indicating the desired number of timesteps between outputs\n\n\n9\nOutput start time — an integer indicating which time step to begin outputting data\n\n\n10\nOutput end time — an integer indicating which time step to stop outputting data, 0 indicates entire run\n\n\n11\nShould read 0, do not modify\n\n\n\n\n\n7.9.3.3 Set Description\nA set is a set of points at which data are to be output. This can include a vertical column of points, a contiguous series of columns of points (curtain), a horizontal sheet of points, a collection of drifters, a collection of outflows, or any group of points in the three-dimensional domain. The valid set types are:\nPROFILE_1D\nCURTAIN_2D\nSHEET_2D\nDRIFTER\nOUTFLOW\nALL_3D\nGENERAL_3D\nProfiles and curtains require only the (x, y) locations of the base of each column to describe their location. Sheets can be referenced to a layer, a height above user datum, a height above bottom, or a height below the free-surface. Drifters are referenced by their drifter number from 1 to n_drifters. OUTFLOW outputs total flow and average scalar concentrations for flow out of the domain. Outflows are referred to by their bc reference number in bc.dat. ALL_3D simply outputs all points in the domain, and GENERAL_3D at points whose coordinates are individually specified.\nA set description block contains 16 lines, which are as follows:\n\n\n\n\n\n\n\nLine\nDescription\n\n\n\n\n1\nBEGIN SET_DESCRIPTION — begin set statement\n\n\n2\nSet reference number — an integer labelling the set, this can have any value\n\n\n3\nUser label — a name containing no blank spaces labelling the set\n\n\n4\nType of set — one of the 7 valid set type names described above\n\n\n5\nNumber of cells in set — varies by set type: PROFILE: number of vertical columns; CURTAIN2D: number of columns making up the curtain; DRIFTER: number of drifters to output; OUTFLOW: number of outflow bc sets to output; SHEET_2D, ALL_3D: use 0\n\n\n6\nSheet type — only for SHEET_2D. Valid keywords: LAYER: referenced as layer number up from bottom; HEIGHT: height in meters above datum; BOTTOM: meters above bottom; SURFACE: meters below free-surface (evolves in time); FLAT: flat calculation layer\n\n\n7\nSheet calc — only for SHEET_2D. Valid options: NEAREST: nearest vertical grid point; MAX: maximum in column (only with FLAT); MIN: minimum in column (only with FLAT); AVG: average in column (only with FLAT); TOTAL: integrated column value (only with FLAT)\n\n\n8\nSheet value — LAYER: layer number; HEIGHT, BOTTOM, SURFACE: vertical distance in meters; FLAT: use 0\n\n\n9–16\nNot implemented, do not modify\n\n\n\n\n\n7.9.3.4 Group data types\nThis block begins with the desired number of data types, followed by a listing of the desired data types.\n\n\n\n\n\n\n\nLine\nDescription\n\n\n\n\n1\nBEGIN GROUP_DATA_TYPES — Begin data type description\n\n\n2\nGroup reference number — An integer referencing the group number defined in the group description\n\n\n3–n\nData types — One data type descriptor per line. The possible data type descriptors are:\n\n\n\n&lt;TEMPERATURE&gt;\n&lt;SALINITY&gt;\nU_VELOCITY\nV_VELOCITY\nW_VELOCITY\nDENSITY\nEXTINCTION\nF_PRESSURE\nT_PRESSURE\nRI\nSHEAR\nMIX_ENERGY\nMIX_FRACTION\nMIX_REGIME\nSHEAR_ENERGY\nWIND_ENERGY\nBBL_ENERGY\nDISSIPATION\nRETENTION_T\nHEIGHT\nSLOPE_X\nSLOPE_Y\nWIND_SPEED\nWIND_DIR\nWIND_U\nWIND_V\nRAIN\nREL_HUM\nLW_RAD_IN\nLW_RAD_NET\nSOLAR_RAD\nATM_PRESS\nCLOUDS\nAIR_TEMP\nAUX_1\nAUX_2\nAUX_3\nAUX_4\nAUX_5\nEVAP_VOL_FLUX\nEVAP_MASS_FLUX\nEVAP_HEAT_FLUX\nSENS_HEAT_FLUX\nHUMIDITY_ALT\nHUMIDITY_SURF\nC_WIND\nC_HEAT\nUnderflow Variables:\n&lt;SCALAR&gt;_UND\nH_UND\nU_UND\nV_UND\nDENSITY_UND\nPRESSURE_UND\nE_COEFF_UND\nRI_UND\nE_VOLUME_UND\nE_VEL_XS_UND\nXP_F_UND_INDEX\nYP_F_UND_INDEX\nXN_F_UND_INDEX\nYN_F_UND_INDEX\nFor DRIFTER set types the value output is the value at the location of the bottom of the drifter.\nFor OUTFLOW set types the scalar value output is the average value for the total flow out. Note: Scalar is actually estimated using a first-order upwind scheme rather than the actual ULTIMATE-QUICKEST flux values.\n\n\n\n7.9.4 Group Time List\nThis block is required to initialize a time stamp for each group. It requires only two lines as follows:\n\n\n\n\n\n\n\nLine\nDescription\n\n\n\n\n1\nBEGIN GROUP_TIME_LIST — Begin group time list\n\n\n2\nGroup reference number — An integer referencing the group number defined in the group description\n\n\n\n\n\n\n7.9.5 Set Cell Data\nThis block describes the spatial location of each datablock set. The locations are described as row, column, and/or layer number.\n\n\n\n\n\n\n\nLine\nDescription\n\n\n\n\n1\nBEGIN SET_CELL_DATA — Begin set cell data\n\n\n2\nSet reference number — An integer referencing the set number defined in the set description\n\n\n3–n\nCell locations — This input varies for different set types as follows:\n\n\n\nSet type-specific input formats:\n\nPROFILE: Each profile requires a row of input. Each row requires 4 integers: x-row, y-column, 0, 0\nCURTAIN_2D: Each profile making up the curtain requires a row of input. Each row requires 4 integers: x-row, y-column, 0, 0\nSHEET_2D: No input required.\nDRIFTER: The drifters to be output. Each row requires 4 integers: drifter number, 0, 0, 0\nOUTFLOW: The bc sets to be output. Each row requires 4 integers: bcset number (from bc.dat), 0, 0, 0\nALL_3D: No input required.\nGENERAL_3D: Each point requires a row of input. Each row requires 3 integers: x-row, y-column, z-layer",
    "crumbs": [
      "Using ELCOM",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>ELCOM Operation</span>"
    ]
  },
  {
    "objectID": "03-elcom.html#sec-runexe",
    "href": "03-elcom.html#sec-runexe",
    "title": "7  ELCOM Operation",
    "section": "7.10 Running ELCOM",
    "text": "7.10 Running ELCOM\nELCOM is executed at the command line by typing elcom.exe within the directory where the run_elcom.dat and all the appropriate input data files are located. The monitoring/debugging output is sent to the standard output of the computer (the display terminal on most computers). Unless the simulation run is very short, it is recommended that the user redirect the output to a file with a execution redirection such as:\nelcom.exe &gt;& run_output.txt\n\n7.10.1 Post-Processing\n\n7.10.1.1 Conversion of datablock file to NETCDF\nThe datablock output files are named and configured through the datablock.db file. ELCOM produces Fortran unformatted (binary) files as specified by the datablock output configuration. In general, one datablock output file contains one or more data types (e.g. velocity, temperature) applied to a set of points at a specified time interval. These files can be reprocessed into NETCDF files using the command-line program dbconv.exe.\nThe program dbconv.exe is used for converting datablock unformatted binary files created by ELCOM to NETCDF files which can then be processed and viewed in a program such as Matlab. The dbconv.exe executable should be placed either in the working directory or as recommended in the /bin directory which is in the operating system’s search path. dbconv is run through a configuration file called run_dbconv.dat.\nThe run_dbconv.dat file contains 9 lines as follows:\n Comment line, up to 64 characters\n .unf file name and path\n sparsedata.unf file name and path\n .nc netcdf output file name and path\n Start time step, -1 for beginning\n End time step, -1 for end of file\n Overwriting of .nc file? -  clobber for overwriting, no_clobber for no overwriting\n Output mapping info to text file? -  map for writing, no_map for no overwriting\n Output diagnosics to monitor?  -  echo to output to monitor, no_echo to not output to monitor\nAn example run_dbconv.dat file would be:\n Example dbconv\n unfiles/curtain.unf\n infiles/sparsedata.unf\n ncfiles/curtain.nc\n -1\n -1\n clobber\n no_map\n no_echo\nOnce the run_dbconv.dat file is correctly configured, dbconv can be executed at the command line by typing:\ndbconv.exe run_dbconv.dat\nNotes:\n\nrun_dbconv.dat can have any file name, however the correct file name must be invoked at run time.\nThe run_dbconv.dat can only be configured for one file at a time.\n\nFor batch processing of several .unf files, it is recommended that a run_dbconv.dat file be created for each .unf to be converted and dbconv.exe be invoked for each run_dbconv.dat using a batch file.",
    "crumbs": [
      "Using ELCOM",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>ELCOM Operation</span>"
    ]
  },
  {
    "objectID": "03-elcom.html#save-and-restart-output-files",
    "href": "03-elcom.html#save-and-restart-output-files",
    "title": "7  ELCOM Operation",
    "section": "7.11 Save and Restart output files",
    "text": "7.11 Save and Restart output files\nSave and Restart output files are Fortran unformatted (binary) files that contain run configuration information used to allow the user to restart ELCOM runs from a certain point. As described in the run_elcom.dat section, the kernel name and output frequency of save and restart files are defined in the run_elcom.dat file.\nThe save files are created starting at the time step specified by the value assigned to the run_elcom.dat keyword start_output_save, and subsequently at intervals defined by iter_out_save. The file name of the save files begins with the user-specified kernel, given by restart_save_file, appended by a time stamp, and appended by .unf.\nThe restart files are created at intervals defined by iter_out_restart, starting from the first time step. Subsequent restart files overwrite existing restart files. The file name of the restart files begins with the user-specified kernel, given by restart_out_file, appended by .unf. All start and restart files are written in the outfiles directory specified in the run_elcom.dat file.\nTo restart an ELCOM simulation using a save or restart file, the user must place a copy of the desired save or restart file in the infiles directory as specified in the run_elcom.dat file. In the run_elcom.dat file the name of the desired save or restart file must be assigned to the restart_infile keyword, and keyword irestart must be assigned the value 1.",
    "crumbs": [
      "Using ELCOM",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>ELCOM Operation</span>"
    ]
  },
  {
    "objectID": "03-elcom.html#culvert-outputs---dynamic-boundary-conditions",
    "href": "03-elcom.html#culvert-outputs---dynamic-boundary-conditions",
    "title": "7  ELCOM Operation",
    "section": "7.12 Culvert Outputs - Dynamic Boundary Conditions",
    "text": "7.12 Culvert Outputs - Dynamic Boundary Conditions\nIn the current implementation, the flow rates and scalars calculated for each pipe in each of the pairs of dynamic boundary condition sets are output to an ASCII file located in the outfile_txt_dir directory.\nThe output files are named culvert_bcset_[$set$].out, where $set$ is each of the dynamic boundary condition sets present in the simulation.\nThe format of the files is as follows. 16 header lines explain the format of the file.\n % number of pipes in set = n (repeats n times)\n % set ref 1 (repeats n times)\n % set ref 2 (repeats n times)\n % pipe heights 1 to n\n % pipe diameters 1 to n\n % number of scalars (repeats n times)\n % names of scalars (repeats n times)\n % Then, for each time step\n % time step (repeats n times)\n % height set upstream\n % height set downstream (repeats n times)\n % total flow (repeats n times)\n % shift in set (repeats n times)\n % regime pipe 1 to n\n % flow pipe 1 to n\n % each scalars flowing through the culverts (repeats n times)\nThe percentage symbols at the beginning of each text line were used to make it easier to load the numeric data into a Matlab environment.\nThe next 7 lines give the set and pipe information.\n\nFirst line gives the number of pipes (n) in the dynamic boundary condition output set. The information repeats n times for easier loading into Matlab.\nSecond line gives the first defined set reference number in the dynamic boundary condition output set ref 1. The information repeats n times.\nThird line gives the second defined set reference number in the dynamic boundary condition output set ref 2. The information repeats n times.\nFourth line gives the bottom height for each of the pipes in the boundary condition set.\nFifth line gives the pipe diameter for each of the pipes in the dynamic boundary condition output set.\nSixth line gives the number of transportable scalars used in the simulation. The information repeats n times.\nSeventh line gives the names of transportable scalars used in the simulation. The information repeats n times and the line is preceded by a percentage symbol.\n\nThen, for each time step in the simulation, 7 + number of scalars lines are output.\n\nFirst line gives the time step of the output t. The information repeats n times.\n\n % flow pipe 1 to n\n % each scalar flowing through the culverts (repeats n times)\n\nSecond line gives the water height in the upstream cell of the dynamic boundary condition set at time step t. Repeats n times.\nThird line gives the water height in the downstream cell of the dynamic boundary condition set at time step t. Repeats n times.\nFourth line gives the sum of the flow in all the pipes in the dynamic boundary condition set at time step t. Repeats n times.\nFifth line tells if there was a shift in the direction of the flow. A value 1 means there was a shift (flow is from cells defined in reference set ref 2 to ref 1), and a value 0 means no shift. Repeats n times.\nSixth line gives the flow regime in each of the pipes (see the science manual for a description of flow regimes).\nSeventh line gives the flow in each of the pipes.\n\nThen, number of scalars lines are output for each of the transportable scalars defined in the header.",
    "crumbs": [
      "Using ELCOM",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>ELCOM Operation</span>"
    ]
  },
  {
    "objectID": "03-elcom.html#sec-validScalars",
    "href": "03-elcom.html#sec-validScalars",
    "title": "7  ELCOM Operation",
    "section": "7.13 ELCOM Valid Scalars",
    "text": "7.13 ELCOM Valid Scalars\n\n\n\n\n\n\n\n\nScalar Keyword\nUnits\nDescription\n\n\n\n\nSALINITY\nPSU\nsalinity (practical salinity units which can be treated as parts per thousand within the numerical resolution of the model)\n\n\nWTR_TEMP\ndegC\nwater temperature for inflowing water\n\n\nTRACER_1 - TRACER_10\nconcentration\ntracer input\n\n\n&lt;CAEDYM&gt;\nconcentration\nCAEDYM Scalars",
    "crumbs": [
      "Using ELCOM",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>ELCOM Operation</span>"
    ]
  },
  {
    "objectID": "04-notation.html",
    "href": "04-notation.html",
    "title": "8  Notation",
    "section": "",
    "text": "Table ?tbl-var-notation shows the variable notation used throughout.",
    "crumbs": [
      "Using ELCOM",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Notation</span>"
    ]
  },
  {
    "objectID": "05-application.html",
    "href": "05-application.html",
    "title": "9  Applications",
    "section": "",
    "text": "9.1 Example one\nSome significant applications are demonstrated in this chapter.",
    "crumbs": [
      "Examples",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Applications</span>"
    ]
  },
  {
    "objectID": "05-application.html#example-two",
    "href": "05-application.html#example-two",
    "title": "9  Applications",
    "section": "9.2 Example two",
    "text": "9.2 Example two",
    "crumbs": [
      "Examples",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Applications</span>"
    ]
  }
]