# Pre-Processor {#pre}

## Introduction

The ELCOM pre-processor is used to convert the user's three-dimensional data of lake bathymetry, boundary forcing sections, and grid structure into one-dimensional vectors used by ELCOM. Configuration for running the pre-processor comes from a `run_pre.dat` file. The `run_pre.dat` file is a text file that contains the names and locations of user-supplied input files and pre-processor output files. The pre-processor requires two or three user-supplied text files: `bathymetry.dat`, `bc.dat` and optionally `levee.dat` and `update.dat`.

- `bathymetry.dat` describes the bathymetry of the lake and grid configuration.
- `bc.dat` defines sets of boundary cells.
- `levee.dat` allows the specification of levee cells — solid walls between two adjacent ELCOM cells.
- `update.dat` allows the specification of update cells — to modify values of various scalars arbitrarily.

The pre-processor outputs two Fortran unformatted (binary) files: `sparsedata.unf` and `usedata.unf`. These may be renamed, but the user must track which are `sparsedata` and which are `usedata`.

## Setting up the bathymetry file (`bathymetry.dat`) {#sect-bathFile}

ELCOM uses Fortran 90 (with F95 extensions) to map 3D space into a single vector for fast operation. Only computational cells containing water are represented in the vector, minimizing memory usage. This enables parallelization/vectorization without platform-specific modifications. Future ELCOM versions may include dynamic pressure effects to handle nonlinear internal wave dynamics.

### Introduction

The bathymetry file allows the user to input the simulation domain geometry at the target resolution[^1].

[^1]: The pre-processor cannot interpolate between coarse/fine grids — this must be done manually beforehand.

The format is strict with respect to data amount and order. All items must be present. Comment lines can be added before bathymetry values, with each line containing at least two items. An item may be an integer, real number, or character string. Comments must begin with an exclamation point (`!`) and include at least two items. A common crash involves a Fortran error due to missing non-optional items or insufficient items per line.

Below are valid formats:

keyword data
data keyword
! comment
keyword keyword
data(j=1 to y_columns)


The keywords are ELCOM-defined words that indicate the type of user-provided data presented: 
(1) before the keyword, 
(2) after the keyword, or 
(3) on succeeding lines of the file.  

Additional comments may be provided after the keywords to help the user remember the keyword purpose (the code only reads the first two items on a line). Detailed information on the keywords and the format of the file are presented in the following sections.

### Physical and computational space coordinates

In the literature, bathymetry is generally presented as the vertical distance from some horizontal baseline (often a mean water height) and may be either positive downward or positive upward. The convention used in ELCOM is an \((x,y,z)\) space that follows the right-hand rule and has \(z\) positive in the upward direction (Figure \@ref(fig:coords)).

The user is free to choose any suitable \(z=0\) baseline for the bathymetry as long as positive \(z\) upward is maintained as the convention for measurement. The pre-processor will adjust the user-defined \(z=0\) baseline to an internal code baseline that is suitable for the ELCOM simulation.

For the most part, the user does not need to know or consider this internal baseline adjustment. However, some debugging or monitoring output is presented in terms of the code coordinate system rather than the user coordinate system, so care must be taken in interpreting debugging output that is intended for use by code developers.

The position of the physical space origin \((x=0, y=0)\) is set implicitly by the user through the layout of the bathymetry data in the file `bathymetry.dat`. This will be covered in more detail below. Physical space \(x\) and \(y\) values may not be negative (i.e., the \(x,y\) origin must be in a corner of the domain).

```{r fig.coords, echo=FALSE, out.width="70%", fig.cap="Schematic of coordinate system", fig.align="center"}
knitr::include_graphics("Elcom_user/02-pre/coords.pdf")
```

ELCOM performs its simulation on computational cells of a three-dimensional Cartesian mesh. The user needs to understand the layout of the mesh so that boundary condition cells can be properly identified. ELCOM allows non-uniform spacing in each of the horizontal dimensions (\(x\) and \(y\)) and allows non-uniform spacing in the vertical (\(z\)) direction. (Although non-uniform \(x\) and \(y\) grid spacings are now allowed, users must be aware that timestep limitations are set by the smallest grid size.)

Figure \@ref(fig:pmesh) shows a plan view (\(x\)-\(y\) plane) of a lake with a discrete (uniform) Cartesian mesh overlay. The computational domain is divided into "cells" whose centers are represented in Figure \@ref(fig:pmesh) by solid dots. Dashed lines represent the faces between the cells. Each cell center has an \((i,j,k)\) coordinate that designates its location in discrete computational space. The \(i,j,k\) values are the integer indices of a three-dimensional array.

The right-hand rule is used, with \((i,j,k)\) being non-zero, positive integer values; \(k = 1\) is associated with the lowermost cell layer in the domain. The \((i,j)\) pairs of a horizontal plane represent a matrix, so that by conventional mathematical notation the \((1,1)\) position is always in the upper left corner. The \(i\) index is the row index and increases *down* the page. The \(j\) index is the column index and increases across the page. The \((i,j)\) indices for corner cells are shown in Figure \@ref(fig:pmesh).

For convenience and consistency, the origin \((0,0)\) of the \(x,y\) (physical space) coordinates is taken to be at the \((1,1)\) location in the computational space \(i,j\) indices.

```{r fig.pmesh, echo=FALSE, out.width="70%", fig.cap="Plan view of Cartesian mesh", fig.align="center"}
knitr::include_graphics("Elcom_user/02-pre/pview_cart_mesh.pdf")
```

Using the upper left corner as the origin may initially be confusing to users familiar with mirror-image storage (used by many graphics programs) where the *lower* left corner is stored in position \(i=1,j=1\). The problem with mirror-image storage is that a simple printout of bathymetry data always appears as an upside-down mirror image of the real world when viewed with a text processor or spreadsheet.

The present convention gives the user a *What You See Is What You Get* view of the bathymetry simply by opening the file with a word processor or importing into a spreadsheet. This convention has been found to be intuitive for users who are not graphics experts. However, caution needs to be taken when converting raw bathymetry data from graphics programs that use a mirror-image standard. Likewise, the direction of the positive \(u\) (\(x\) direction) velocity is confusing, as it is positive down the page.

Figure \@ref(fig:pbath) shows the *physical* space outline of the lake as the border of the shaded area. The discrete outline of a lake is shown with a heavy solid line. In developing a `bathymetry.dat` file for an ELCOM simulation, the user is required to provide bathymetry values (i.e., vertical distance measured from the user's \(z=0\) baseline) for each of the cells within the discrete boundary of the lake. The region outside the lake boundary is defined as the "land" region.

In Figure \@ref(fig:pbath), the cell center dots have been replaced with numbers that represent the distance from the user's \(z=0\) baseline to the bottom of the lake. In this case, all of the "land" regions have been given a value of 99. Note that the boundary of the bathymetry data set shown in Figure \@ref(fig:pbath) has land values around the entire boundary.

In general, it is required that either a land cell or open boundary cell surrounds the bathymetry data. For the purposes of the `bathymetry.dat` file, the user must provide bathymetry values for *all* cells in a rectangular array, including those cells that only contain land. ELCOM will only reserve computational memory for:

1. The cells which may contain water, and  
2. The first layer of land cells surrounding the water cells.

```{r fig.pbath, echo=FALSE, out.width="70%", fig.cap="Plan view of bathymetry data", fig.align="center"}
knitr::include_graphics("elcom_user/02-pre/pview_bath.pdf")
```

Figure \@ref(fig:emesh) shows an elevation view (in the \(x\text{-}z\) plane) of a lake with a Cartesian overlay. A continuous, *physical-space* lake bottom is shown as a dashed line, with the resulting discrete lake bottom shown as a solid line.

ELCOM computes the bathymetry on the face of each cell (the dashed lines) from user-supplied bathymetry data at the cell centers (on the solid dots). In this figure, the user \(z=0\) baseline is chosen as the top of the domain, so that all the bathymetry values should be negative. Note that the \(k=1\) index of \(i,j,k\) space corresponds with the lowermost layer, regardless of the user *z=0* baseline position.

```{r fig.emesh, echo=FALSE, out.width="70%", fig.cap="Elevation view of bathymetry data", fig.align="center"}
knitr::include_graphics("elcom_user/02-pre/eview_cart_mesh.png")
```

An up-to-date copy of `bathymetry.dat` is included in the examples. This file can be used as a template for creating your own `bathymetry.dat` file. The judicious use of extra comment lines and comments after the keywords leads to a file that is much more readable. The `bathymetry.dat` file can be renamed, but the corresponding name in the `run_pre.dat` must also be changed.

The remainder of this section will detail the use of each keyword in the `bathymetry.dat` file.

### File header

**keyword =** `FILE`

The first non-comment line of the `bathymetry.dat` file must begin with the keyword `FILE`. Thus, the first non-comment line *must* appear as shown:

&nbsp;

| Keyword            | Value             |
|--------------------|-------------------|
| `FILE`             | `bathymetry.dat`  |

#### Description lines

**keywords =** `TITLE`, `ANALYST`, `ORGANIZATION`, `COMMENT`

Several keywords are provided to allow the user to put identifying information at the top of the bathymetry file. This information is printed to the standard output at the start of the run to provide identification of the debugging output data. The format for the header lines is `'string'; keyword`, where the string must be a non-null character array enclosed in single quotation marks. If the string is left blank or not enclosed in quotes, the pre-processor will crash with a Fortran read error. The user must have only one `COMMENT` line. A typical set of header keywords is shown below.

&nbsp;

| Value                 | Keyword      |
|-----------------------|--------------|
| `'Lake Nowhere'`      | `TITLE`      |
| `'J. Citizen'`        | `ANALYST`    |
| `'A Company'`         | `ORGANIZATION` |
| `'test run number 1'` | `COMMENT`    |

### Size of input bathymetry data

**keywords =** `x_rows`, `y_columns`, `z_layers`, `n_max`, `n_maxBC`

In order to correctly read the bathymetry data from file `bathymetry.dat`, the user must tell the pre-processor the size of grid to expect. The value for `x_rows` is the number of rows in a two dimensional plan view of the bathymetry. The `y_columns` is the number of columns in the two-dimensional plan view. The number of layers in the vertical direction is identified with the keyword `z_layers`. The keyword `n_max` is used to set an estimate of the number of grid cells in the domain that are required for simulation (i.e. interior points plus the land points in one layer surrounding the interior). For most simulations, `n_max` can be set to 0, and the code will start with an estimate of `x_rows` × `y_columns` × `z_layers`. However, in some cases, this may create a temporary data array larger than can be processed using the available memory and the pre-processor will crash. The crash may produce a machine error message stating "out of memory," or a more enigmatic "segmentation fault". If insufficient memory is available, the user can estimate the actual number of grid points required for the simulation and rerun the preprocessor. Further reduction of the amount of memory used can be achieved by using the keyword `n_maxBC`. `n_maxBC` sets the maximum number of cells in any one boundary condition set. If `n_maxBC` is not specified or is set to 0 then the calculated `n_max` value is used.

| Value | Keyword     |
|-------|-------------|
| 102   | `x_rows`    |
| 84    | `y_columns` |
| 22    | `z_layers`  |
| 0     | `n_max`     |

---

### Land cells

**keyword =** `land_value`

The land region is designated by a unique bathymetry value (defined using the keyword `land_value`) that is greater than any value found within the lake. The user is free to choose the `land_value` as any convenient number that meets this criterion. Thus, if the user chooses a `z=0` baseline at the very top of the domain, the `land_value` may be set to zero (and all the bathymetry values should be negative numbers). If the user chooses the bottom of the domain as the *z=0* baseline, then the `land_value` may be any positive number that is greater than the largest number appearing within the lake boundary (it is usually convenient to use 9999). In this latter case, all the bathymetry values will be positive numbers. Note that any cell whose bathymetry is not equal to the `land_value` is considered a cell within the domain; thus typographical errors can produce spurious interior cells of the domain. The user is not required to have a `z=0` baseline within the domain: it may be convenient to use an external reference such as sea level. This may result in the lowest point in the domain having a positive non-zero bathymetry value.

| Value  | Keyword      |
|--------|--------------|
| 9999   | `land_value` |

---

### Open boundary cells

**keyword =** `open_value`

Open boundary cells are boundaries with tidal forcing from an adjacent body of water that is not in the simulation domain. The user-defined bathymetry value that indicates an open boundary cell is defined with the keyword `open_value`.

| Value  | Keyword      |
|--------|--------------|
| 8888   | `open_value` |

---

### North vector

**keywords =** `north_x`, `north_y`

The user may create a bathymetry data file with any orientation (i.e., there is no requirement that north be at the top of the page). Since wind forcing on the free surface requires a direction, the user must designate the north direction. The north vector is determined as shown in Figure \ref{fig:north}. Note that the north vector is given in terms of a vector in physical ($x,y,z$) space, not the discrete ($i,j,k$) space. Because the origin is in the upper left corner, a standard "north up" data set has a north vector of (-1, 0).

| Value | Keyword     |
|-------|-------------|
| -1.0  | `north_x`   |
| 0.5   | `north_y`   |

![Calculation of the north vector](elcom_user/02-pre/north){#fig:north}

---

### Geographic position

**keywords =** `latitude`, `longitude`, `altitude`

The user provides the geographic position of the simulation domain using the keywords `latitude`, `longitude` and `altitude`. Longitude and altitude have no effect on the simulation but longitude is used to geo-reference output data. The latitude is used to provide appropriate Coriolis forcing in the ELCOM simulation. North latitudes are entered as positive numbers while south latitudes are entered as negative numbers. Latitude and longitude refer to the *top,left* corner of the bathymetry file.

| Value  | Keyword    |
|--------|------------|
| -32.0  | `latitude` |
| 9.46   | `longitude`|
| 0.0    | `altitude` |

---

### Horizontal grid spacing

**keywords =** `x_grid`, `y_grid`

The present version of ELCOM allows uniform or stretched grid spacing in the $x$ and $y$ direction. Separate grid spacings are implemented in each horizontal dimension so that $dx \neq dy$ is valid. However, the user should be careful in implementing a solution grid with different $dx$ and $dy$ grid spacings since this can affect the solution accuracy. For uniform grids the $x$ and $y$ grid spacings are designated with the keywords `x_grid` and `y_grid`. If a non-uniform (stretched) horizontal grid is used, a default value for `x_grid` and `y_grid` must still be defined.

| Value   | Keyword   |
|---------|-----------|
| 100.0   | `x_grid`  |
| 100.0   | `y_grid`  |

### Non uniform horizontal grid spacing

**keywords =** `dx`, `dy` (optional)

In the horizontal direction, ELCOM version 2.0.0 allows the user to design a grid whose dimension varies in space (i.e. \( dx = f[x] \) and \( dy = f[y] \)). Note that the \( dx \) may not vary with \( y \) or \( z \) coordinates and \( dy \) may not vary with \( x \) or \( z \) coordinates. In the `bathymetry.dat` file, stretched horizontal grid spacings are designated by the keywords `dx` and `dy`. `dx` and `dy` are defined in the `bathymetry.dat` in the order of increasing coordinate (i.e. from \( x=1 \) to \( x = x\_rows \)).

While the user is free to set the \( dx \) and \( dy \) values in an arbitrary manner, the accuracy and stability of the simulation method may be affected by the degree of non-uniformity of the grid. In general, the simulation method will perform best (i.e. with greatest accuracy) using a uniform grid. For non-uniform grids, the degradation of accuracy is a function of the rate at which the grid changes (see below for \( dz \)).

| Value | Keyword |
|-------|----------|
| 100   | `dx`     |
| 100   | `dx`     |
| 120   | `dx`     |
| 132   | `dx`     |
| 145   | `dx`     |
| 150   | `dx`     |
| 165   | `dx`     |
| 171   | `dx`     |
| 188   | `dx`     |
| 205   | `dx`     |
| 205   | `dx`     |
| 205   | `dx`     |
| 205   | `dx`     |
| 205   | `dx`     |

| Value | Keyword |
|-------|----------|
| 100   | `dy`     |
| 100   | `dy`     |
| 120   | `dy`     |
| 132   | `dy`     |
| 145   | `dy`     |
| 150   | `dy`     |
| 165   | `dy`     |
| 171   | `dy`     |
| 188   | `dy`     |
| 205   | `dy`     |
| 205   | `dy`     |
| 205   | `dy`     |
| 205   | `dy`     |
| 205   | `dy`     |

---

### Layer thickness

**keyword =** `dz`

In the vertical direction, ELCOM allows the user to design a structure of horizontal layers whose thickness varies with depth (i.e. \( dz = f[z] \)). Note that the layer thickness may not vary with \( x \) or \( y \) coordinates. In the `bathymetry.dat` file, the successive layer thicknesses (in descending order from the top of the domain) are designated by the keyword `dz`. While the user is free to set the \( dz \) values in an arbitrary manner, the accuracy and stability of the simulation method may be affected by the degree of non-uniformity of the layers. In general, the simulation method will perform best (i.e. with greatest accuracy) using a grid with uniform \( dz \). For non-uniform \( dz \), the degradation of accuracy is a function of the rate at which the \( dz \) changes. Thus, a grid that has a \( dz \) that varies slowly will perform very well, while a grid with abrupt changes in grid size will be less accurate. For example, Figure \ref{fig:vgrid} shows two possible configurations which provide vertical resolution of 0.5 metres in the upper portion of a lake and 2.0 metre resolution in the lower portion. Both use the same number of grid cells, but the \( dz \) distribution on the left of Figure \ref{fig:vgrid} will show better performance.

| Value | Keyword |
|-------|---------|
| 0.5   | `dz`    |
| 0.5   | `dz`    |
| 0.5   | `dz`    |
| 0.51  | `dz`    |
| 0.54  | `dz`    |
| 0.58  | `dz`    |
| 0.65  | `dz`    |
| 0.75  | `dz`    |
| 0.90  | `dz`    |
| 1.13  | `dz`    |
| 1.41  | `dz`    |
| 1.65  | `dz`    |
| 1.88  | `dz`    |
| 2.0   | `dz`    |

---

![Vertical grid spacings](Elcom_user/02-pre/vgrid.pdf){#fig:vgrid}

*Figure \ref{fig:vgrid}:* Vertical grid spacings

### Bathymetry values

**keywords** = `BATHYMETRY DATA`

The bathymetry values must be presented in the file `bathymetry.dat` following a line with the two keywords `BATHYMETRY DATA`. Each line of bathymetry values must contain exactly `y_columns` of data and there must be exactly `x_rows` of data lines following `BATHYMETRY DATA`. Each value on the line may be separated from the next by one or more spaces or tabs. 

Thus, for a domain with `x_rows` = 8 and `y_columns` = 13, and `land_value` = 99 (i.e., similar to Figure \@ref(fig:pmesh)), the bathymetry values would be entered into the `bathymetry.dat` file as shown:

`BATHYMETRY DATA`

```
99  99  99   99   99   99   99   99   99   99   99   99   99
99  99  -0.7 -0.5 99   99   99   99   99   99   99   99   99
99  -0.4 -1.2 -1.3 -1.1 -1.4 -2.5 -2.7 -3.3 -0.7 99   99   99
99  -1.1 -1.6 -2.2 -3.2 -3.8 -3.9 -4.1 -5.3 -5.7 -5.2 -2.4 99
99  -0.5 -0.8 -1.2 -2.1 -2.2 -2.4 -3.2 -3.3 -4.1 -5.0 -1.8 99
99  99  99   99   99   99   99   99   99   -1.7 -1.2 -0.7 99
99  99  99   99   99   99   99   99   99   -0.7 -0.9 -0.3 99
99  99  99   99   99   99   99   99   99   99   99   99   99
```

### Bottom drag values (optional)

**Keywords**: `BTM_CD DATA`

Version 2.0.0 allows a variable bottom drag coefficient to be specified in the `bathymetry.dat` file. Each line of values must contain exactly `y_columns` of data and there must be exactly `x_rows` of data lines following `BTM_CD DATA`. Each value on the line may be separated from the next by one or more spaces.

Thus, for the domain with `x_rows = 8` and `y_columns = 13`, the values would be entered into the `bathymetry.dat` file as shown:

```
BTM_CD DATA
8 13 1e+16
1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16
1e+16 1e+16 0.002 0.002 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16
1e+16 0.002 0.002 0.002 0.002 0.002 0.002 0.002 0.002 0.002 1e+16 1e+16 1e+16
1e+16 0.003 0.003 0.003 0.003 0.003 0.003 0.003 0.003 0.003 0.003 0.003 1e+16
1e+16 0.004 0.004 0.004 0.004 0.004 0.004 0.004 0.004 0.004 0.004 0.004 1e+16
1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 0.004 0.004 0.004 1e+16
1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 0.004 0.004 0.004 1e+16
1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16
```

### Bottom Slope Values (Optional)

**Keywords:** `SLOPE_X DATA`, `SLOPE_Y DATA`

To enable the 2D underflow model, bottom slope values must be included in the `bathymetry.dat` file. These values should follow a line containing either of the keywords `SLOPE_X DATA` or `SLOPE_Y DATA`.

Each line of slope values must contain exactly `y_columns` entries, and there must be exactly `x_rows` lines of data following the keyword. Values on a line can be separated by one or more spaces or tabs.

For instance, if the domain is defined with `x_rows = 8` and `y_columns = 13` (as shown earlier), the slope values would appear in the `bathymetry.dat` file as follows:



#### Example SLOPE_X DATA Format {-}

```
SLOPE_X DATA
8 13 1e+16

1e+16  1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16
1e+16  1e+16 -0.006 -0.008 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16
1e+16 -0.007 -0.004 -0.008 -0.021 -0.024 -0.019 -0.020 -0.026 -0.05 1e+16 1e+16 1e+16
1e+16 -0.000 0.002 0.000 -0.005 -0.004 0.000 -0.002 0.000 -0.017 -0.025 -0.009 1e+16
1e+16  0.005 0.008 0.011 0.016 0.019 0.0195 0.020 0.026 0.02 0.02 0.008 1e+16
1e+16  1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 0.017 0.020 0.007 1e+16
1e+16  1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 0.008 0.006 0.003 1e+16
1e+16  1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16 1e+16
```

#### Example SLOPE_Y DATA Format {-}

```
SLOPE_Y DATA
8 13 1e+16

1e+16  1e+16  1e+16   1e+16   1e+16   1e+16   1e+16   1e+16   1e+16   1e+16   1e+16   1e+16   1e+16
1e+16  1e+16 -0.002   0.003   1e+16   1e+16   1e+16   1e+16   1e+16   1e+16   1e+16   1e+16   1e+16
1e+16 -0.008 -0.004   0.000  -0.000  -0.007  -0.006  -0.004   0.01    0.016   1e+16   1e+16   1e+16
1e+16 -0.008 -0.005  -0.008  -0.008  -0.003  -0.001  -0.007  -0.008   0.000   0.016   0.026   1e+16
1e+16  1e+16  1e+16   1e+16   1e+16   1e+16   1e+16   1e+16   1e+16   0.017   0.005   0.006   1e+16
1e+16  1e+16  1e+16   1e+16   1e+16   1e+16   1e+16   1e+16   1e+16  -0.004   0.002   0.004   1e+16
1e+16  1e+16  1e+16   1e+16   1e+16   1e+16   1e+16   1e+16   1e+16   1e+16   1e+16   1e+16   1e+16
```

---

## Setting up the boundary cell set file (`bc.dat`) {#sect:bcFile}

An up-to-date copy of `bc.dat` is included in the examples.


## Introduction

The boundary cell set file designates logical grouping of grid cells over which boundary conditions are enforced in ELCOM. One set of points may have a river inflow, another set may have a dam offtake, another set may represent groundwater inflows, etc. Each set of boundary points is defined by a unique *reference number* (used also by ELCOM temporal boundary condition files), *type* (one of several keywords), *title* (user reference only), and a series of cell *i, j, k* coordinates. This file gives the user complete flexibility in the assignment of diverse and complex boundary conditions around a three-dimensional topography.

## Boundary cell set categories

The keywords for the boundary cell sets fall into seven categories, defined as follows:

| **Keyword**           | **Description**                                                                                                                                                                                                                   |
|-----------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `land`                | Cell boundary which is considered to be land, on which a Dirichlet `no-slip` condition is imposed on all components of the velocity, and a Neumann `zero-gradient` condition is imposed on transported scalars.                  |
| `slip`                | Cell boundary which is considered to be land, but on which the velocity components tangential to the boundary have a Neumann `free-slip` condition applied, while the normal component of the velocity is a Dirichlet `no-flux` condition (this may be thought of more precisely as normal Dirichlet, tangential Neumann, or NDTN). A Neumann `zero-gradient` condition is imposed on transported scalars. |
| `flow`                | Cell boundary through which an inflow or outflow will be imposed as a Dirichlet `fixed velocity` condition. This also enforces a Dirichlet condition on transported scalars.                                                    |
| `section`             | Cell boundary which is grouped into a set for application of an environmental forcing or scalar forcing boundary condition, but does not change the underlying form of the velocity boundary condition (e.g., the free surface may be divided into sections over which different wind conditions may be enforced - the type velocity boundary condition is not changed, but its magnitude is adjusted on different sections). |
| `open`                | Cell boundary which is `open` to inflows and outflows from another body of water where the velocity is not fixed *a priori* (i.e., not a Dirichlet boundary) but is a function of the baroclinic and barotropic forcing near the boundary. |
| `bubbler`             | An interior cell on which a bubble plume destratification will be simulated.                                                                                                                                                     |
| `flow_*_dynamic`      | Cell boundary through which flow is determined dynamically according to the head difference between two locations in the domain (implemented for horizontal culverts). The flow will be imposed as a Dirichlet `fixed velocity` condition and also enforces a Dirichlet condition on transported scalars. |


A boundary cell set consists of a collection of cell *faces* that are the boundaries between *interior* cell and *land* cells. The `land` boundary condition is the default for all faces of cells identified by the `land_value` in the `bathymetry.dat` file and for all boundary cell faces below the bathymetry data. As such, the user will rarely need to use a `land` boundary condition in the `bc.dat` file. For a lake without any inflows, outflows or special boundary conditions, the `bc.dat` file need not be present.

## Boundary cell set face direction

The cell faces of the boundaries are identified by the `(i, j, k)` coordinates of the interior cell and the direction from the cell center to the boundary. The conventions used are as follows:

| **Face code**    | **Description**                                             |
|------------------|-------------------------------------------------------------|
| `xp`             | the *y-z* cell face in the positive x direction from the cell center |
| `yp`             | the *x-z* cell face in the positive y direction from the cell center |
| `xm`             | the *y-z* cell face in the negative x direction from the cell center |
| `ym`             | the *x-z* cell face in the negative y direction from the cell center |
| `top`            | the *x-y* cell face above the cell                           |
| `all_sides`      | all possible side boundary faces (i.e., all *y-z* and *x-z* faces) |
| `all`            | all possible side boundary faces plus the bottom boundary   |

## Boundary cell set keywords

The keywords used to identify boundary cell sets are a concatenation of the categories and the face direction. The valid keywords are listed below:

| `land_xp`          | `flow_xp`          | `slip_xp`          | `section_xp`       |
|--------------------|--------------------|--------------------|--------------------|
| `land_xm`          | `flow_xm`          | `slip_xm`          | `section_xm`       |
| `land_yp`          | `flow_yp`          | `slip_yp`          | `section_yp`       |
| `land_ym`          | `flow_ym`          | `slip_ym`          | `section_ym`       |
| `land_bottom`      | `flow_bottom`      | `slip_bottom`      | `section_bottom`   |
| `land_all_sides`   | `flow_all_sides`   | `slip_all_sides`   | `section_all_sides`|
| `land_all`         | `flow_all`         | `slip_all`         | `section_all`      |
|                    |                    |                    | `section_top`      |

---

| `bubbler`          | `bubbler_zbot`     | `bubbler_kbot`     |                    |
|--------------------|--------------------|--------------------|--------------------|
| `open_cell`        |                    |                    |                    |
| `flow_multi_sides` |                    |                    |                    |
| `flow_xp_dynamic`  | `flow_xm_dynamic`  | `flow_yp_dynamic`  | `flow_ym_dynamic`  |

**NOTE:** `bubbler_zbot` and `bubbler_kbot` allow the user to specify the height of a bubble plume diffuser as either some height in metres (`zbot`) or number of cells from the bottom.

## Organization of the boundary cell set file (`bc.dat`){#sect:bc.dat}

At the top of the boundary cell set file (`bc.dat`), the user may put any number of comment lines. Each comment line must start with an exclamation point (`!`) and have at least 3 items on the line (i.e., two words or numbers separated from the exclamation point and each other by spaces or tabs). After the initial comments, the boundary cell set file consists of a series of definitions of boundary sets. Each set consists of a *set identification line* followed by one or more lines of *cell definitions*. Each line must have three items on it or the pre-processor will crash with a Fortran file read error. Blank lines are not allowed in the boundary cell set file.

Each set identification line is of the form:  
`integer  keyword  title`

The first item, `integer`, is a *reference number* for the boundary cell set that is used in preparing temporal boundary condition data files for the ELCOM simulation run (see section \ref{sect:tempBCfiles}). Each boundary cell set must have a unique `integer` reference number. The `keyword` is one of the valid keywords listed in Table \ref{tab:keywords}. The `title` is a user-designated name for the boundary condition set. The `title` may have more than one word, although only the first word will be used by the code.

After the set identification line, there will be one or more lines of cell definitions. A cell definition consists of three sets of numbers in the general form:
`i_{start}:i_{end}  j_{start}:j_{end}  k_{start}:k_{end}`. 
For all boundary condition types except `bubbler_zbot` and `bubbler_kbot` the `i`, `j`, and `k` are integer values of the cell positions in space for a rectangular box of cells on which the relevant boundary cell keyword will be applied. For `bubbler_zbot` the third column must be a single real which gives the height of the diffuser in metres above the lake bottom. For `bubbler_kbot` the third column must be a single integer which gives the number of cells the diffuser is above the lake bottom. An example of a simple boundary cell set definition might be

```plaintext
  107  flow_xp  river_inflow
   3:10  4:5  10:14
```

The preprocessor would designate as a single set, all positive x boundaries in the range \(3 \leq i \leq 10\) and \(4 \leq j \leq 5\) and \(10 \leq k \leq 14\). A boundary cell set may have multiple lines of cell definitions:


```plaintext
  13  flow_bottom  groundwater_inflow
	5:10   1:5    10:14
	5:10   7:11   10:14
	3:8   12:17   1:5
```

Note that each number pair in a cell definition must be in increasing order.

There are two simpler cases for implementing boundary cell sets (1) where \(i, j\) or \(k\) is a single value rather than a range, (2) where all possible values in \(i, j\) or \(k\) are to be included. In the former case, only a single number needs to be provided (rather than a pair), in the latter case, only the colon (`:`) needs to be listed. For example, the cell set for an inflow boundary along a flat side where \(j = 2\) might be written as:

```plaintext
  214  slip_all  freeslip_domain
	:  :  :
```

which enforces a free-slip boundary condition on all boundary faces (sides and bottom) of the domain.

There is no error cross-checking within the pre-processor for cell faces which have been defined as belonging to more than one boundary cell set. In some cases, multiple definitions may be desirable.  For example, one might define a river inflow which covers the entire depth of the river for purposes of the velocity boundary condition; and then define a separate section at the bottom of the river that is used to place a tracer.  The bc.dat file might then contain

```plaintext
  2791	flow_ym     river_inflow
	3:15    2    :
  73    section_ym  tracer_inflow
	3:15    2    1:5
```

In other cases, multiple set definitions for a particular face can produce unintended results. For example, if we define an inflow boundary and a global definition of free-slip boundaries on all the cells:

```plaintext
2791	flow_ym	river_inflow
	3:15	2	:
214	slip_all	freeslip_domain
	:	:	:
```

We then find that the cells (3:15, 2, : ) get defined both with imposed velocity (Dirichlet) boundary conditions and free-slip (normal-Dirichlet, tangential-Neumann) boundary conditions. Obviously this is inconsistent and the flow simulation cannot enforce both boundary conditions. Checking for which combinations of multiple definitions are consistent and which are not is an error capturing routine that is not yet implemented. Thus, the above boundary cell sets would be processed and provided to ELCOM. Within ELCOM, only one of the two boundary conditions will actually be enforced, but one cannot tell \emph{a priori} which boundary condition it will be without detailed examination of source code. Note that the order the items are defined may affect the operation of an inconsistent definition. Thus if the above inconsistent definition were reversed and written as:

```plaintext
214	slip_all	freeslip_domain
	:	:	:
2791	flow_ym	river_inflow
	3:15	2	:
```

The results in ELCOM may be different than the previous implementation — *they would be wrong in a different manner*. As a general rule, the user should not provide multiple definitions of velocity boundary conditions on a single cell face. The `land`, `flow` and `slip` keywords all affect the type of velocity boundary condition; it is incumbent on the user to be sure that the cell faces defined with these types do not have multiple definitions.

The following table illustrates a `bc.dat` file with a few subtle uses of the boundary cell set definitions. A flow boundary has been declared on the x-minus faces of cells with \(i=2\). Thus, to get free-slip boundary conditions on all the other faces, we use the keyword `slip_all` for cells with \(i>2\). Then to get free slip on the y-minus and y-plus faces at \(i=2\) requires two more definitions (These are not inconsistent with the `flow_xm` definition since they are on different faces of the same cell). This file also shows the use of the `section_top` to segregate the free surface into different sets onto which different wind data can be enforced.


```plaintext
! - - - -
! - bc.dat file
! - comment lines need three items
34  flow_xm   outflow_number_1
	2       :       :
75  section_top  wind_region_a
	:       1:10    :
118 section_top  wind_region_b
	:       11:21   :
25  slip_all_sides  free_slip_section
	3:34    :       :
26  slip_ym free_slip_near_inflow_1
	2:      :       :
27  slip_yp free_slip_near_inflow_2
	2:      :       :
```

## flow_multi_sides

In ELCOM version 2.1.1 a further bc set type was introduced (`flow_multi_sides`) which allows the user to specify one inflow which enters from multiple cells on multiple faces. This was primarily introduced to allow a meandering river channel to be specified as one boundary set and will be particularly useful when coupled with `INFLOW_DEPTH` boundary condition data. The format of `flow_multi_sides` in the boundary cell set file (`bc.dat`) is slightly different from other set types.

Each `flow_multi_sides` set consists of a set identification line followed by one or more subsets of cell and face type definitions. Each line must have three items on it or the pre-processor will crash with a Fortran file read error. Blank lines are not allowed in the boundary cell set file.

Each `flow_multi_sides` set identification line is the same as for all other set types, i.e.:

`reference number` `keyword` `title`

Where `keyword` must be `flow_multi_sides`. After the set identification line, there will be one or more subset definitions. Each subset consists of a *subset set identification line* followed by one or more lines of *cell definitions*.

Each subset identification line is of the form: `reference number flow_multi_sides keyword.`  
The subset `reference number` for each subset must be the same as the *reference number* from the set identification line.  
The `keyword.` must be one of `flow_xp`, `flow_xm`, `flow_yp`, or `flow_y` and defines the inflow face or the subset of cells.

Following each subset identification line are one or more lines of cell definitions.  
These cell definitions are the same as for an ordinary set type—i.e., of the general form  
`$i_{start}:i_{end} j_{start}:j_{end} k_{start}:k_{end}$`.

An example of a `flow_multi_sides` boundary cell set definition might be:

```plaintext
  111 flow_multi_sides    river_inflow
  111 flow_multi_sides    flow_xm
	  2   3   10
	  3   3   9
	  4   3   8
  111 flow_multi_sides    flow_ym
	  4   3   8
	  4   4   7
	  4   5   6
  111 flow_multi_sides    flow_xm
	  4   5   6
	  5   5   5
	  6   5   4
```

## flow_dynamic

Dynamic boundary condition sets (`flow*_dynamic`) allow the user to specify the connection of two parts of the domain with a (horizontal) culvert. This functionality was recently introduced in ELCOM. A boundary condition set pair related to each of the ends of the culvert must be defined.

The definition of a dynamic boundary condition pair set comprises four lines. The first and third lines have the same structure as the boundary condition identification line: a set reference number, one of the `keywords` (`flow_xm_dynamic`, `flow_xp_dynamic`, `flow_ym_dynamic`, or `flow_yp_dynamic`), and a user identifier. Each of these lines refers to one end of the culvert.

The second and fourth lines follow the same structure as the cell definition lines of an ordinary set type. Each line refers to one end of the culvert. Only one `i` and one `j` value can be specified. Although multiple `k` values may be included, both ends must have the same `k` specification.

An example of a `flow*_dynamic` boundary cell set definition might be:

```plaintext
500     flow_xp_dynamic pipe_east_end
        2   3   10
600     flow_ym_dynamic pipe_north_end
        4   3   10
```

## Setting up the levee file (`levee.dat`) (Optional) {#sect-leveeFile}

### Introduction

The levee set file designates any levees in the domain. Levees are solid boundaries between two adjacent cells. Pre-ELCOM implements levees by adding additional ghost cells adjacent to the levee. These ghost cells are colocated with the wet cells.

The format of the levee set file is essentially the same as the `bc.dat` file. Each set of levee points is defined by a unique *reference number*, *type* (one of several keywords), *title* (user reference only), and a series of cell `(i, j, k)` coordinates.

### Levee set categories

The cell faces of the levees are identified by the `(i, j, k)` coordinates of the interior cell and the direction from the cell center to the levee. The four valid keywords for the levee sets are as follows:

| Keyword        | Description                                                                 |
|----------------|-----------------------------------------------------------------------------|
| `levee_xp`     | Levee on the *y-z* cell face in the positive x direction from the cell center |
| `levee_yp`     | Levee on the *x-z* cell face in the positive y direction from the cell center |
| `levee_xm`     | Levee on the *y-z* cell face in the negative x direction from the cell center |
| `levee_ym`     | Levee on the *x-z* cell face in the negative y direction from the cell center |

### Organization of the levee set file (`levee.dat`)

At the top of the `levee.dat` file, the user may include any number of comment lines. Each comment line must begin with an exclamation point `!` and contain at least three items (i.e., two words or numbers separated from the `!` and from each other by spaces).

After the initial comments, the file contains a series of levee set definitions. Each set consists of a *set identification line* followed by one or more *cell definition lines*. Each line must have three items; otherwise, the pre-processor will fail with a Fortran file read error. Blank lines are not allowed.

Each set identification line is of the form: `integer keyword title`.  
- `integer`: a *reference number* unique to each levee set  
- `keyword`: one of the valid keywords listed above  
- `title`: a user-designated name for the levee set (only the first word is used by the code)

Each cell definition consists of three fields in the form:  
`i_start:i_end j_start:j_end :`  
Here, `i` and `j` are integer values specifying a rectangular box of cells. The third field must be a colon (`:`), indicating that the levee acts on all `z` values.

An example of a simple levee set definition might be:

```plaintext
107  levee_xp  levee_bank
     3  4:15  :
```

## Setting up the update file (`update.dat`) (Optional) {#sect-updateFile}

### Introduction

The update set file defines update cells in the domain. These cells allow scalar values to be modified arbitrarily at run-time using Update boundary condition files (see [Update BC Files](#sect-updateBCfiles)). The format of this file is essentially the same as the `bc.dat` file.

Each set is defined by a unique *reference number*, *type* (keyword), *title* (user reference), and a series of `(i, j, k)` cell coordinates.

### Update set categories

Update cells are identified by their `(i, j, k)` coordinates. The valid keywords for update sets are:

| Keyword         | Description                                                                 |
|------------------|-----------------------------------------------------------------------------|
| `update`         | Scalar values are set to those in the Update boundary condition files       |
| `update_add`     | Scalar values are increased by the values in the Update boundary files      |
| `update_max`     | Scalar values are set to the maximum of current and file value              |
| `update_scale`   | Scalar values are multiplied by the file value                              |

### Organization of the update set file (`update.dat`)

Comment lines may appear at the top of the file. Each comment must begin with `!` and include at least three items. No blank lines are allowed in the file.

Each update set includes a *set identification line* followed by one or more *cell definition lines*. Each line must have exactly three items to avoid pre-processor errors.

Each set identification line is of the form: `integer keyword title`.  
- `integer`: a unique *reference number*  
- `keyword`: one of the valid update keywords  
- `title`: a user-designated name (only the first word is used by the code)

Each cell definition is of the form:  
`i_start:i_end j_start:j_end k_start:k_end`  
Here, `i`, `j`, and `k` define a rectangular box of update cells.

An example of a simple update set definition might be:

```plaintext
12  update  tracer_release
  3  4:15  2:4
```

## Running the pre-processor with `run_pre.dat`

An up-to-date copy of `run_pre.dat` is included in the examples.

The `run_pre.dat` file is a text file that contains the names and paths of the user-supplied input files and the pre-processor output files. The required input files are:

- `bathymetry.dat`: describes lake bathymetry and grid configuration
- `bc.dat`: defines boundary cell sets

Optionally, it may also include:

- `update.dat`
- `levee.dat`

The pre-processor outputs two unformatted Fortran binary files:

- `sparsedata.unf`
- `usedata.unf`

These files may be renamed by the user, but they must be tracked carefully to distinguish between `sparsedata` and `usedata`.

Once the `run_pre.dat` file is in place with correct file paths and names, the pre-processor is executed with:

```bash
pre_elcom.exe
```
